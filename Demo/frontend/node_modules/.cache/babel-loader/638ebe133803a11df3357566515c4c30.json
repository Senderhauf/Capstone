{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nrequire(\"array.prototype.fill\");\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _d3Shape = require(\"d3-shape\");\n\nvar _merge = require(\"merge\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _pondjs = require(\"pondjs\");\n\nvar _util = require(\"../js/util\");\n\nvar _styler = require(\"../js/styler\");\n\nvar _curve = require(\"../js/curve\");\n\nvar _curve2 = _interopRequireDefault(_curve);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n *  Copyright (c) 2015-present, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar defaultStyle = {\n  line: {\n    normal: {\n      stroke: \"steelblue\",\n      fill: \"none\",\n      strokeWidth: 1\n    },\n    highlighted: {\n      stroke: \"#5a98cb\",\n      fill: \"none\",\n      strokeWidth: 1\n    },\n    selected: {\n      stroke: \"steelblue\",\n      fill: \"none\",\n      strokeWidth: 1\n    },\n    muted: {\n      stroke: \"steelblue\",\n      fill: \"none\",\n      opacity: 0.4,\n      strokeWidth: 1\n    }\n  },\n  area: {\n    normal: {\n      fill: \"steelblue\",\n      stroke: \"none\",\n      opacity: 0.75\n    },\n    highlighted: {\n      fill: \"#5a98cb\",\n      stroke: \"none\",\n      opacity: 0.75\n    },\n    selected: {\n      fill: \"steelblue\",\n      stroke: \"none\",\n      opacity: 0.75\n    },\n    muted: {\n      fill: \"steelblue\",\n      stroke: \"none\",\n      opacity: 0.25\n    }\n  }\n};\n/**\n * The `<AreaChart>` component is able to display single or multiple stacked\n * areas above or below the axis. It used throughout the\n * [My ESnet Portal](http://my.es.net).\n\n * The `<AreaChart>` should be used within a `<ChartContainer>` structure,\n * as this will construct the horizontal and vertical axis, and manage\n * other elements. Here is an example of an `<AreaChart>` with an up and down\n * network traffic visualization:\n *\n *  ```\n *   render() {\n *      return (\n *          ...\n *          <ChartContainer timeRange={trafficSeries.timerange()} width=\"1080\">\n *              <ChartRow height=\"150\">\n *                  <Charts>\n *                      <AreaChart\n *                          axis=\"traffic\"\n *                          series={trafficSeries}\n *                          columns={{up: [\"in\"], down: [\"out\"]}}\n *                       />\n *                  </Charts>\n *                  <YAxis\n *                      id=\"traffic\"\n *                      label=\"Traffic (bps)\"\n *                      min={-max} max={max}\n *                      absolute={true}\n *                      width=\"60\"\n *                      type=\"linear\"\n *                  />\n *              </ChartRow>\n *          </ChartContainer>\n *          ...\n *      );\n *  }\n *  ```\n * The `<AreaChart>` takes a single `TimeSeries` object into its `series` prop. This\n * series can contain multiple columns and those columns can be referenced using the `columns`\n * prop. The `columns` props allows you to map columns in the series to the chart,\n * letting you specify the stacking and orientation of the data. In the above example\n * we map the \"in\" column in `trafficSeries` to the up direction and the \"out\" column to\n * the down direction. Each direction is specified as an array, so adding multiple\n * columns into a direction will stack the areas in that direction.\n *\n * Note: It is recommended that `<ChartContainer>`s be placed within a <Resizable> tag,\n * rather than hard coding the width as in the above example.\n * \n * Note 2 : Columns can't have periods because periods represent a path to deep data \n * in the underlying events (i.e. reference into nested data structures)\n * \n */\n\nvar AreaChart = function (_React$Component) {\n  _inherits(AreaChart, _React$Component);\n\n  function AreaChart() {\n    _classCallCheck(this, AreaChart);\n\n    return _possibleConstructorReturn(this, (AreaChart.__proto__ || Object.getPrototypeOf(AreaChart)).apply(this, arguments));\n  }\n\n  _createClass(AreaChart, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      var newSeries = nextProps.series;\n      var oldSeries = this.props.series;\n      var width = nextProps.width;\n      var timeScale = nextProps.timeScale;\n      var yScale = nextProps.yScale;\n      var interpolation = nextProps.interpolation;\n      var columns = nextProps.columns;\n      var style = nextProps.style;\n      var highlight = nextProps.highlight;\n      var selection = nextProps.selection;\n      var widthChanged = this.props.width !== width;\n      var timeScaleChanged = (0, _util.scaleAsString)(this.props.timeScale) !== (0, _util.scaleAsString)(timeScale);\n      var yAxisScaleChanged = this.props.yScale !== yScale;\n      var interpolationChanged = this.props.interpolation !== interpolation;\n      var columnsChanged = JSON.stringify(this.props.columns) !== JSON.stringify(columns);\n      var styleChanged = JSON.stringify(this.props.style) !== JSON.stringify(style);\n      var highlightChanged = this.props.highlight !== highlight;\n      var selectionChanged = this.props.selection !== selection;\n      var seriesChanged = false;\n\n      if (oldSeries.size() !== newSeries.size()) {\n        seriesChanged = true;\n      } else {\n        seriesChanged = !_pondjs.TimeSeries.is(oldSeries, newSeries);\n      }\n\n      return seriesChanged || timeScaleChanged || widthChanged || interpolationChanged || columnsChanged || styleChanged || yAxisScaleChanged || highlightChanged || selectionChanged;\n    }\n  }, {\n    key: \"handleHover\",\n    value: function handleHover(e, column) {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(column);\n      }\n    }\n  }, {\n    key: \"handleHoverLeave\",\n    value: function handleHoverLeave() {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(null);\n      }\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e, column) {\n      e.stopPropagation();\n\n      if (this.props.onSelectionChange) {\n        this.props.onSelectionChange(column);\n      }\n    }\n  }, {\n    key: \"providedAreaStyleMap\",\n    value: function providedAreaStyleMap(column) {\n      var style = {};\n\n      if (this.props.style) {\n        if (this.props.style instanceof _styler.Styler) {\n          style = this.props.style.areaChartStyle()[column];\n        } else if (_underscore2.default.isFunction(this.props.style)) {\n          style = this.props.style(column);\n        } else if (_underscore2.default.isObject(this.props.style)) {\n          style = this.props.style ? this.props.style[column] : defaultStyle;\n        }\n      }\n\n      return style;\n    }\n    /**\n     * Returns the style used for drawing the path\n     */\n\n  }, {\n    key: \"style\",\n    value: function style(column, type) {\n      var style = void 0;\n      var styleMap = this.providedAreaStyleMap(column);\n      var isHighlighted = this.props.highlight && column === this.props.highlight;\n      var isSelected = this.props.selection && column === this.props.selection;\n\n      if (!_underscore2.default.has(styleMap, \"line\")) {\n        console.error(\"Provided style for AreaChart does not define a style for the outline:\", styleMap, column);\n      }\n\n      if (!_underscore2.default.has(styleMap, \"area\")) {\n        console.error(\"Provided style for AreaChart does not define a style for the area:\", styleMap);\n      }\n\n      if (this.props.selection) {\n        if (isSelected) {\n          style = (0, _merge2.default)(true, defaultStyle[type].selected, styleMap[type].selected ? styleMap[type].selected : {});\n        } else if (isHighlighted) {\n          style = (0, _merge2.default)(true, defaultStyle[type].highlighted, styleMap[type].highlighted ? styleMap[type].highlighted : {});\n        } else {\n          style = (0, _merge2.default)(true, defaultStyle[type].muted, styleMap[type].muted ? styleMap[type].muted : {});\n        }\n      } else if (isHighlighted) {\n        style = (0, _merge2.default)(true, defaultStyle[type].highlighted, styleMap[type].highlighted ? styleMap[type].highlighted : {});\n      } else {\n        style = (0, _merge2.default)(true, defaultStyle[type].normal, styleMap[type].normal ? styleMap[type].normal : {});\n      }\n\n      return style;\n    }\n  }, {\n    key: \"pathStyle\",\n    value: function pathStyle(column) {\n      return this.style(column, \"line\");\n    }\n  }, {\n    key: \"areaStyle\",\n    value: function areaStyle(column) {\n      return this.style(column, \"area\");\n    }\n  }, {\n    key: \"renderArea\",\n    value: function renderArea(data, column, key) {\n      var _this2 = this; // Use D3 to build an area generation function\n\n\n      var style = this.areaStyle(column);\n      var pathStyle = this.pathStyle(column);\n      var areaGenerator = (0, _d3Shape.area)().curve(_curve2.default[this.props.interpolation]).x(function (d) {\n        return d.x0;\n      }).y0(function (d) {\n        return d.y0;\n      }).y1(function (d) {\n        return d.y1;\n      }); // Use the area generation function with our stacked data\n      // to get an SVG path\n\n      var areaPath = areaGenerator(data); // Outline the top of the curve\n\n      var lineGenerator = (0, _d3Shape.line)().curve(_curve2.default[this.props.interpolation]).x(function (d) {\n        return d.x0;\n      }).y(function (d) {\n        return d.y1;\n      });\n      var outlinePath = lineGenerator(data);\n      return _react2.default.createElement(\"g\", {\n        key: \"area-\" + key\n      }, _react2.default.createElement(\"path\", {\n        d: areaPath,\n        style: style\n      }), _react2.default.createElement(\"path\", {\n        d: areaPath,\n        style: style,\n        onClick: function onClick(e) {\n          return _this2.handleClick(e, column);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this2.handleHoverLeave();\n        },\n        onMouseMove: function onMouseMove(e) {\n          return _this2.handleHover(e, column);\n        }\n      }), _react2.default.createElement(\"path\", {\n        d: outlinePath,\n        style: pathStyle,\n        onClick: function onClick(e) {\n          return _this2.handleClick(e, column);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this2.handleHoverLeave();\n        },\n        onMouseMove: function onMouseMove(e) {\n          return _this2.handleHover(e, column);\n        }\n      }));\n    }\n  }, {\n    key: \"renderPaths\",\n    value: function renderPaths(columnList, direction) {\n      var _this3 = this;\n\n      var dir = direction === \"up\" ? 1 : -1;\n      var size = this.props.series.size();\n      var offsets = new Array(size).fill(0);\n      var len = columnList.length;\n      return columnList.map(function (column, i) {\n        // Stack the series columns to get our data in x0, y0, y1 format\n        var pathAreas = [];\n        var count = 1;\n\n        if (_this3.props.breakArea) {\n          var currentPoints = null;\n\n          for (var j = 0; j < _this3.props.series.size(); j += 1) {\n            var seriesPoint = _this3.props.series.at(j);\n\n            var value = seriesPoint.get(column);\n            var badPoint = _underscore2.default.isNull(value) || _underscore2.default.isNaN(value) || !_underscore2.default.isFinite(value);\n            if (badPoint) value = 0; // Case 1:\n            // When stacking is present with multiple area charts, then mark bad points as 0\n\n            if (len > 1) {\n              if (!currentPoints) currentPoints = [];\n              currentPoints.push({\n                x0: _this3.props.timeScale(seriesPoint.timestamp()),\n                y0: _this3.props.yScale(offsets[j]),\n                y1: _this3.props.yScale(offsets[j] + dir * value)\n              });\n\n              if (_this3.props.stack) {\n                offsets[j] += dir * value;\n              }\n            } // Case Two\n            // When only one area chart is to be drawn, then create different areas for each area and ignore nulls and NaNs\n            else {\n                if (!badPoint) {\n                  if (!currentPoints) currentPoints = [];\n                  currentPoints.push({\n                    x0: _this3.props.timeScale(seriesPoint.timestamp()),\n                    y0: _this3.props.yScale(offsets[j]),\n                    y1: _this3.props.yScale(offsets[j] + dir * value)\n                  });\n\n                  if (_this3.props.stack) {\n                    offsets[j] += dir * value;\n                  }\n                } else if (currentPoints) {\n                  if (currentPoints.length > 1) {\n                    pathAreas.push(_this3.renderArea(currentPoints, column, count));\n                    count += 1;\n                  }\n\n                  currentPoints = null;\n                }\n              }\n          }\n\n          if (currentPoints && currentPoints.length > 1) {\n            pathAreas.push(_this3.renderArea(currentPoints, column, count));\n            count += 1;\n          }\n        } else {\n          // Ignore nulls and NaNs in the area chart\n          var cleanedPoints = [];\n\n          for (var _j = 0; _j < _this3.props.series.size(); _j += 1) {\n            var _seriesPoint = _this3.props.series.at(_j);\n\n            var _value = _seriesPoint.get(column);\n\n            var _badPoint = _underscore2.default.isNull(_value) || _underscore2.default.isNaN(_value) || !_underscore2.default.isFinite(_value);\n\n            if (!_badPoint) {\n              cleanedPoints.push({\n                x0: _this3.props.timeScale(_seriesPoint.timestamp()),\n                y0: _this3.props.yScale(offsets[_j]),\n                y1: _this3.props.yScale(offsets[_j] + dir * _value)\n              });\n\n              if (_this3.props.stack) {\n                offsets[_j] += dir * _value;\n              }\n            }\n          }\n\n          pathAreas.push(_this3.renderArea(cleanedPoints, column, count));\n          count += 1;\n        }\n\n        return _react2.default.createElement(\"g\", {\n          key: column\n        }, pathAreas);\n      });\n    }\n  }, {\n    key: \"renderAreas\",\n    value: function renderAreas() {\n      var up = this.props.columns.up || [];\n      var down = this.props.columns.down || [];\n      return _react2.default.createElement(\"g\", null, this.renderPaths(up, \"up\"), this.renderPaths(down, \"down\"));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react2.default.createElement(\"g\", null, this.renderAreas());\n    }\n  }]);\n\n  return AreaChart;\n}(_react2.default.Component);\n\nexports.default = AreaChart;\nAreaChart.propTypes = {\n  /**\n   * What [Pond TimeSeries](https://esnet-pondjs.appspot.com/#/timeseries) data to visualize\n   */\n  series: _propTypes2.default.instanceOf(_pondjs.TimeSeries).isRequired,\n\n  /**\n   * Reference to the axis which provides the vertical scale for ## drawing. e.g.\n   * specifying axis=\"trafficRate\" would refer the y-scale to the YAxis of id=\"trafficRate\".\n   */\n  axis: _propTypes2.default.string.isRequired,\n  // eslint-disable-line\n\n  /**\n   * Show or hide this chart\n   */\n  visible: _propTypes2.default.bool,\n\n  /**\n   * The series series columns mapped to stacking up and down.\n   * Has the format:\n   * ```\n   *  \"columns\": {\n   *      up: [\"in\", ...],\n   *      down: [\"out\", ...]\n   *  }\n   *  ```\n   *\n   * NOTE : Columns can't have periods because periods\n   * represent a path to deep data in the underlying events\n   * (i.e. reference into nested data structures)\n   */\n  columns: _propTypes2.default.shape({\n    up: _propTypes2.default.arrayOf(_propTypes2.default.string),\n    down: _propTypes2.default.arrayOf(_propTypes2.default.string)\n  }),\n\n  /**\n   * Stack areas on top of each other\n   */\n  stack: _propTypes2.default.bool,\n\n  /**\n   * The styles to apply to the underlying SVG lines. This is a mapping\n   * of column names to objects with style attributes, in the following\n   * format:\n   *\n   * ```\n   * const style = {\n   *     in: {\n   *         line: {\n   *             normal: {stroke: \"steelblue\", fill: \"none\", strokeWidth: 1},\n   *             highlighted: {stroke: \"#5a98cb\", fill: \"none\", strokeWidth: 1},\n   *             selected: {stroke: \"steelblue\", fill: \"none\", strokeWidth: 1},\n   *             muted: {stroke: \"steelblue\", fill: \"none\", opacity: 0.4, strokeWidth: 1}\n   *         },\n   *         area: {\n   *             normal: {fill: \"steelblue\", stroke: \"none\", opacity: 0.75},\n   *             highlighted: {fill: \"#5a98cb\", stroke: \"none\", opacity: 0.75},\n   *             selected: {fill: \"steelblue\", stroke: \"none\", opacity: 0.75},\n   *             muted: {fill: \"steelblue\", stroke: \"none\", opacity: 0.25}\n   *         }\n   *     },\n   *     out: {\n   *         ...\n   *     }\n   * };\n   *\n   * <AreaChart style={style} ... />\n   * ```\n   *\n   * Alternatively, you can pass in a Styler. For example:\n   *\n   * ```\n   * const upDownStyler = styler([\n   *     {key: \"in\", color: \"#C8D5B8\"},\n   *     {key: \"out\", color: \"#9BB8D7\"}\n   * ]);\n   *\n   * <AreaChart columns={[\"in\", \"out\"]} style={upDownStyler} ... />\n   *\n   * ```\n   */\n  style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func, _propTypes2.default.instanceOf(_styler.Styler)]),\n\n  /**\n   * Any of D3's interpolation modes.\n   */\n  interpolation: _propTypes2.default.oneOf([\"curveBasis\", \"curveBasisOpen\", \"curveBundle\", \"curveCardinal\", \"curveCardinalOpen\", \"curveCatmullRom\", \"curveCatmullRomOpen\", \"curveLinear\", \"curveMonotoneX\", \"curveMonotoneY\", \"curveNatural\", \"curveRadial\", \"curveStep\", \"curveStepAfter\", \"curveStepBefore\"]),\n\n  /**\n   * The currenly highlighted column\n   */\n  highlight: _propTypes2.default.string,\n\n  /**\n   * Callback called when the highlight changes, i.e. hover event\n   */\n  onHighlightChange: _propTypes2.default.func,\n\n  /**\n   * The currenly selected column\n   */\n  selection: _propTypes2.default.string,\n\n  /**\n   * Callback called when the selection changes, i.e. area is clicked\n   */\n  onSelectionChange: _propTypes2.default.func,\n\n  /**\n   * [Internal] The timeScale supplied by the surrounding ChartContainer\n   */\n  timeScale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The yScale supplied by the associated YAxis\n   */\n  yScale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The width supplied by the surrounding ChartContainer\n   */\n  width: _propTypes2.default.number,\n\n  /**\n   * The determines how to handle bad/missing values in the supplied\n   * TimeSeries. A missing value can be null or NaN. If breakArea\n   * is set to true then the area chart will be broken on either side of\n   * the bad value(s). If breakArea is false (the default) bad values\n   * are simply removed and the adjoining points are connected.\n   */\n  breakArea: _propTypes2.default.bool\n};\nAreaChart.defaultProps = {\n  visible: true,\n  interpolation: \"curveLinear\",\n  columns: {\n    up: [\"value\"],\n    down: []\n  },\n  stack: true,\n  breakArea: true\n};","map":null,"metadata":{},"sourceType":"script"}