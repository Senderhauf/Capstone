{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _merge = require(\"merge\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _styler = require(\"../js/styler\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n *  Copyright (c) 2015-present, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar defaultStyle = {\n  symbol: {\n    normal: {\n      stroke: \"steelblue\",\n      fill: \"none\",\n      strokeWidth: 1\n    },\n    highlighted: {\n      stroke: \"#5a98cb\",\n      fill: \"none\",\n      strokeWidth: 1\n    },\n    selected: {\n      stroke: \"steelblue\",\n      fill: \"none\",\n      strokeWidth: 2\n    },\n    muted: {\n      stroke: \"steelblue\",\n      fill: \"none\",\n      opacity: 0.4,\n      strokeWidth: 1\n    }\n  },\n  label: {\n    normal: {\n      fontSize: \"normal\",\n      color: \"#333\"\n    },\n    highlighted: {\n      fontSize: \"normal\",\n      color: \"#222\"\n    },\n    selected: {\n      fontSize: \"normal\",\n      color: \"#333\"\n    },\n    muted: {\n      fontSize: \"normal\",\n      color: \"#333\",\n      opacity: 0.4\n    }\n  },\n  value: {\n    normal: {\n      fontSize: \"normal\",\n      color: \"#333\"\n    },\n    highlighted: {\n      fontSize: \"normal\",\n      color: \"#222\"\n    },\n    selected: {\n      fontSize: \"normal\",\n      color: \"#333\"\n    },\n    muted: {\n      fontSize: \"normal\",\n      color: \"#333\",\n      opacity: 0.4\n    }\n  }\n};\n/**\n * Legends are simple to define.\n *\n * First specify the styles you want each item to have. This is either\n * the CSS that should be appied to rendered symbol. Or you can provide\n * a Styler object. See below for full styling details.\n *\n * ```\n * const style = Styler([\n *     {key: \"aud\", color: \"steelblue\", width: 1, dashed: true},\n *     {key: \"euro\", color: \"#F68B24\", width: 2}\n * ]);\n * ```\n *\n * Next build a list of categories you want in the legend.\n *\n * ```\n * const categories = [\n *     {key: \"aust\", label: \"AUD\", value: \"1.52\", disabled: true},\n *     {key: \"usa\", label: \"USD\", value: \"1.43\", disabled: false}\n * ];\n * ```\n * For each category to display you must provide a key, a label and\n * if it should be displayed disabled or not.\n *\n * Then render the legend, with type either \"line\", \"swatch\" or \"dot\":\n *\n * ```\n * <Legend type=\"line\" style={style} categories={categories} />\n * ```\n *\n * Optionally you can also display a value below the label. This is\n * useful when hovering over another chart on the page, or to display\n * the current value of live data. You can see this defined in the\n * above categories.\n *\n * The legend can also be supplied with callback functions which will\n * tell you if the user has clicked or hovered over on one of the legend\n * items. You can use this to sync highlighting and selection to a\n * chart.\n *\n * ## Styling\n *\n * There are three methods of styling a legend:\n *  - using a Styler object\n *  - using an object containing inline styles\n *  - using a function which returns an inline style\n *\n * A Styler object can be supplied directly to the `style` prop\n * of the legend. This is the simplest approach, since you can\n * usually just use the same Styler as you use for your chart.\n *\n * Supplying an object to the `style` prop gives you more control\n * than the Styler, since you can provide the actual CSS properties\n * for each element of the legend. The format for the object is:\n *\n * ```\n * {\n *     columnName1: {\n      symbol: {\n        normal: {...styleSymbol},\n        highlighted: {...styleSymbol},\n        selected: {...styleSymbol},\n        muted: {...styleSymbol}\n      },\n      label: {\n        normal: {...labelStyle},\n        highlighted: {...labelStyle},\n        selected: {...labelStyle},\n        muted: {...labelStyle}\n      },\n      value: {\n        normal: {...valueStyle},\n        highlighted: {...valueStyle},\n        selected: {...valueStyle},\n        muted: {...valueStyle}\n      }\n *     },\n *     columnName2 : {\n *         ...\n *     },\n *     ...\n *  }\n *\n *  - symbolStyle is the CSS properties for the symbol, which\n * is either a swatch, dot or line. For a line, you'd want to\n * provide the SVG <line> properties, for a swatch you'd provide\n * the SVG <rect> properties and for a dot the <ellipse> properties.\n *  - labelStyle is the main label for the legend item. It is a\n *  SVG <text> element, so you can control the font properties.\n *  - valueStyle is the optional value. As with the labelStyle you\n *  this is an SVG <text> element.\n *\n * Finally, you can provide a function to the `style` prop. This\n * is similar to providing an object, except your function will\n * be called with the columnName and you should return the map\n * containing symbol, label and value styles.\n */\n\nvar LegendItem = function (_React$Component) {\n  _inherits(LegendItem, _React$Component);\n\n  function LegendItem() {\n    _classCallCheck(this, LegendItem);\n\n    return _possibleConstructorReturn(this, (LegendItem.__proto__ || Object.getPrototypeOf(LegendItem)).apply(this, arguments));\n  }\n\n  _createClass(LegendItem, [{\n    key: \"handleClick\",\n    value: function handleClick(e, key) {\n      e.stopPropagation();\n\n      if (this.props.onSelectionChange) {\n        this.props.onSelectionChange(key);\n      }\n    }\n  }, {\n    key: \"handleHover\",\n    value: function handleHover(e, key) {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(key);\n      }\n    }\n  }, {\n    key: \"handleHoverLeave\",\n    value: function handleHoverLeave() {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(null);\n      }\n    }\n  }, {\n    key: \"renderLine\",\n    value: function renderLine(style) {\n      var _props = this.props,\n          symbolWidth = _props.symbolWidth,\n          symbolHeight = _props.symbolHeight;\n      return _react2.default.createElement(\"svg\", {\n        style: {\n          float: \"left\"\n        },\n        width: symbolWidth,\n        height: symbolHeight\n      }, _react2.default.createElement(\"line\", {\n        style: style,\n        x1: 0,\n        y1: parseInt(symbolWidth / 2, 10),\n        x2: symbolWidth,\n        y2: parseInt(symbolWidth / 2, 10),\n        stroke: \"black\",\n        strokeWidth: \"2\"\n      }));\n    }\n  }, {\n    key: \"renderSwatch\",\n    value: function renderSwatch(style) {\n      var _props2 = this.props,\n          symbolWidth = _props2.symbolWidth,\n          symbolHeight = _props2.symbolHeight;\n      return _react2.default.createElement(\"svg\", {\n        style: {\n          float: \"left\"\n        },\n        width: symbolWidth,\n        height: symbolHeight\n      }, _react2.default.createElement(\"rect\", {\n        style: style,\n        x: 2,\n        y: 2,\n        width: symbolWidth - 4,\n        height: symbolHeight - 4,\n        rx: 2,\n        ry: 2\n      }));\n    }\n  }, {\n    key: \"renderDot\",\n    value: function renderDot(style) {\n      var _props3 = this.props,\n          symbolWidth = _props3.symbolWidth,\n          symbolHeight = _props3.symbolHeight;\n      var w = parseInt(symbolWidth / 2, 10);\n      var h = parseInt(symbolHeight / 2, 10);\n      var radius = w * 0.75;\n      return _react2.default.createElement(\"svg\", {\n        style: {\n          float: \"left\"\n        },\n        width: symbolWidth,\n        height: symbolHeight\n      }, _react2.default.createElement(\"circle\", {\n        style: style,\n        cx: w,\n        cy: h,\n        r: radius\n      }));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _props4 = this.props,\n          symbolStyle = _props4.symbolStyle,\n          labelStyle = _props4.labelStyle,\n          valueStyle = _props4.valueStyle,\n          itemKey = _props4.itemKey,\n          symbolType = _props4.symbolType;\n      var symbol = void 0;\n\n      switch (symbolType) {\n        case \"swatch\":\n          symbol = this.renderSwatch(symbolStyle);\n          break;\n\n        case \"line\":\n          symbol = this.renderLine(symbolStyle);\n          break;\n\n        case \"dot\":\n          symbol = this.renderDot(symbolStyle);\n          break;\n\n        default: //pass\n\n      } // TODO: We shouldn't be adding interactions to a element like this.\n      //       The alternative it to put it on a <a> or something?\n\n\n      return _react2.default.createElement(\"div\", {\n        style: {\n          display: \"flex\",\n          flexDirection: \"column\"\n        },\n        key: itemKey,\n        onClick: function onClick(e) {\n          return _this2.handleClick(e, itemKey);\n        },\n        onMouseMove: function onMouseMove(e) {\n          return _this2.handleHover(e, itemKey);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this2.handleHoverLeave();\n        }\n      }, _react2.default.createElement(\"div\", {\n        style: {\n          display: \"flex\",\n          flexDirection: \"row\",\n          alignItems: \"center\"\n        }\n      }, _react2.default.createElement(\"div\", {\n        style: {\n          width: \"20px\"\n        }\n      }, symbol), _react2.default.createElement(\"div\", {\n        style: {\n          display: \"flex\",\n          flexDirection: \"column\"\n        }\n      }, _react2.default.createElement(\"div\", {\n        style: labelStyle\n      }, this.props.label), _react2.default.createElement(\"div\", {\n        style: valueStyle\n      }, this.props.value))));\n    }\n  }]);\n\n  return LegendItem;\n}(_react2.default.Component);\n\nvar Legend = function (_React$Component2) {\n  _inherits(Legend, _React$Component2);\n\n  function Legend() {\n    _classCallCheck(this, Legend);\n\n    return _possibleConstructorReturn(this, (Legend.__proto__ || Object.getPrototypeOf(Legend)).apply(this, arguments));\n  }\n\n  _createClass(Legend, [{\n    key: \"handleClick\",\n    value: function handleClick(e, key) {\n      e.stopPropagation();\n\n      if (this.props.onSelectionChange) {\n        this.props.onSelectionChange(key);\n      }\n    }\n  }, {\n    key: \"handleHover\",\n    value: function handleHover(e, key) {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(key);\n      }\n    }\n  }, {\n    key: \"handleHoverLeave\",\n    value: function handleHoverLeave() {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(null);\n      }\n    }\n    /**\n     * For each category item we get the users stle preference. This\n     * can be supplied in a number of ways:\n     *  * Typically you would get the legend stle from a Style instance\n     *  * Alternatively, you can pass in a style object which has your\n     *    category in it and the associated style\n     *  * Finally, the provided style can also be a function\n     */\n\n  }, {\n    key: \"providedStyle\",\n    value: function providedStyle(category, type) {\n      var style = {};\n\n      if (this.props.style) {\n        if (this.props.style instanceof _styler.Styler) {\n          style = this.props.style.legendStyle(category.key, type);\n        } else if (_underscore2.default.isFunction(this.props.style)) {\n          style = this.props.style(category.key);\n        } else if (_underscore2.default.isObject(this.props.style)) {\n          style = this.props.style ? this.props.style[category.key] : defaultStyle;\n        }\n      }\n\n      return style;\n    }\n    /**\n     * For each category this function takes the current\n     * selected and highlighted item, along with the disabled\n     * state of the item, and returns the mode it should be\n     * rendered in: normal, selected, highlighted, or muted\n     */\n\n  }, {\n    key: \"styleMode\",\n    value: function styleMode(category) {\n      var isHighlighted = this.props.highlight && category.key === this.props.highlight;\n      var isSelected = this.props.selection && category.key === this.props.selection;\n      var isDisabled = category.disabled;\n      var mode = \"normal\";\n\n      if (this.props.selection) {\n        if (isSelected) {\n          mode = \"selected\";\n        } else if (isHighlighted) {\n          mode = \"highlighted\";\n        } else {\n          mode = \"muted\";\n        }\n      } else if (isHighlighted) {\n        mode = \"highlighted\";\n      } else if (isDisabled) {\n        mode = \"muted\";\n      }\n\n      return mode;\n    }\n  }, {\n    key: \"symbolStyle\",\n    value: function symbolStyle(category, type) {\n      var styleMap = this.providedStyle(category, type);\n      var styleMode = this.styleMode(category);\n      return (0, _merge2.default)(true, defaultStyle[styleMode], styleMap.symbol ? styleMap.symbol[styleMode] : {});\n    }\n  }, {\n    key: \"labelStyle\",\n    value: function labelStyle(category) {\n      var styleMap = this.providedStyle(category);\n      var styleMode = this.styleMode(category);\n      return (0, _merge2.default)(true, defaultStyle[styleMode], styleMap.label ? styleMap.label[styleMode] : {});\n    }\n  }, {\n    key: \"valueStyle\",\n    value: function valueStyle(category) {\n      var styleMap = this.providedStyle(category);\n      var styleMode = this.styleMode(category);\n      return (0, _merge2.default)(true, defaultStyle[styleMode], styleMap.value ? styleMap.value[styleMode] : {});\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _props5 = this.props,\n          _props5$type = _props5.type,\n          type = _props5$type === undefined ? \"swatch\" : _props5$type,\n          symbolWidth = _props5.symbolWidth,\n          symbolHeight = _props5.symbolHeight;\n      var items = this.props.categories.map(function (category) {\n        var key = category.key,\n            label = category.label,\n            value = category.value,\n            _category$symbolType = category.symbolType,\n            symbolType = _category$symbolType === undefined ? type : _category$symbolType;\n\n        var symbolStyle = _this4.symbolStyle(category, symbolType);\n\n        var labelStyle = _this4.labelStyle(category);\n\n        var valueStyle = _this4.valueStyle(category);\n\n        return _react2.default.createElement(LegendItem, {\n          key: key,\n          type: type,\n          itemKey: key,\n          label: label,\n          value: value,\n          symbolType: symbolType,\n          symbolWidth: symbolWidth,\n          symbolHeight: symbolHeight,\n          symbolStyle: symbolStyle,\n          labelStyle: labelStyle,\n          valueStyle: valueStyle,\n          onSelectionChange: _this4.props.onSelectionChange,\n          onHighlightChange: _this4.props.onHighlightChange\n        });\n      });\n      var align = this.props.align === \"left\" ? \"flex-start\" : \"flex-end\";\n\n      if (this.props.stack) {\n        return _react2.default.createElement(\"div\", {\n          style: {\n            display: \"flex\",\n            justifyContent: align,\n            flexDirection: \"column\",\n            marginBottom: this.props.marginBottom\n          }\n        }, items);\n      } else {\n        return _react2.default.createElement(\"div\", {\n          style: {\n            display: \"flex\",\n            justifyContent: align,\n            flexWrap: \"wrap\",\n            marginBottom: this.props.marginBottom\n          }\n        }, items);\n      }\n    }\n  }]);\n\n  return Legend;\n}(_react2.default.Component);\n\nexports.default = Legend;\nLegend.propTypes = {\n  /**\n   * The overall style of the legend items, either a color \"swatch\", a\n   * colored \"line\", or a \"dot\".\n   */\n  type: _propTypes2.default.oneOf([\"swatch\", \"line\", \"dot\"]),\n\n  /**\n   * Alignment of the legend within the available space. Either left or right.\n   */\n  align: _propTypes2.default.oneOf([\"left\", \"right\"]),\n  style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func, _propTypes2.default.instanceOf(_styler.Styler)]),\n\n  /**\n   * The categories array specifies details and style for each item in the legend. For each item:\n   *  * \"key\" - (required) the name by which the legend will be known\n   *  * \"label\" - (required) the displayed label\n   *  * \"style\" - the swatch, dot, or line style. Typically you'd just\n   *              specify {backgroundColor: \"#1f77b4\"}\n   *  * \"labelStyle\" - the label style\n   *  * \"disabled\" - a disabled state\n   *\n   * ```\n   * const categories = [\n   *    {key: \"aust\", label: \"AUD\", disabled: this.state.disabled[\"aust\"],\n   *      style: {backgroundColor: \"#1f77b4\"}},\n   *    {key: \"usa\", label: \"USD\", disabled: this.state.disabled[\"usa\"],\n   *      style: {backgroundColor: \"#aec7e8\"}}\n   * ];\n   * ```\n   */\n  categories: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    key: _propTypes2.default.string.isRequired,\n    // eslint-disable-line\n    label: _propTypes2.default.string.isRequired,\n    // eslint-disable-line\n    disabled: _propTypes2.default.bool,\n    // eslint-disable-line\n    style: _propTypes2.default.object,\n    // eslint-disable-line\n    labelStyle: _propTypes2.default.object // eslint-disable-line\n\n  })).isRequired,\n\n  /**\n   * The width of the legend symbol\n   */\n  symbolWidth: _propTypes2.default.number,\n\n  /**\n   * The height of the legend symbol\n   */\n  symbolHeight: _propTypes2.default.number,\n\n  /**\n   * Which item, specified by its key, should be rendered as highlighted\n   */\n  highlight: _propTypes2.default.string,\n\n  /**\n   * Which item, specified by its key, should be rendered as selected\n   */\n  selection: _propTypes2.default.string,\n\n  /**\n   * Callback will be called with a legend item is selected (i.e. it is clicked\n   * on by the user)\n   */\n  onSelectionChange: _propTypes2.default.func,\n\n  /**\n   * Callback will be called with a legend item is highlighted (i.e. it is hovered\n   * over by the user)\n   */\n  onHighlightChange: _propTypes2.default.func,\n\n  /**\n   * Defines whether to stack legend items vertically or not\n   */\n  stack: _propTypes2.default.bool,\n\n  /**\n   * The margin at the bottom. Default value is 20px\n   */\n  marginBottom: _propTypes2.default.string\n};\nLegend.defaultProps = {\n  style: {},\n  labelStyle: {},\n  type: \"swatch\",\n  // or \"line\" or \"dot\"\n  align: \"left\",\n  symbolWidth: 16,\n  symbolHeight: 16,\n  stack: false,\n  marginBottom: \"20px\"\n};","map":null,"metadata":{},"sourceType":"script"}