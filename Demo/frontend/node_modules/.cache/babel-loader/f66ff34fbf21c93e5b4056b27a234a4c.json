{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filter = undefined;\nexports.keep = keep;\nexports.sum = sum;\nexports.avg = avg;\nexports.max = max;\nexports.min = min;\nexports.count = count;\nexports.first = first;\nexports.last = last;\nexports.difference = difference;\nexports.median = median;\nexports.stdev = stdev;\nexports.percentile = percentile;\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction isValid(v) {\n  return !(_underscore2.default.isUndefined(v) || _underscore2.default.isNaN(v) || _underscore2.default.isNull(v));\n} //\n// Functions to process missing values out of a value list\n//\n\n/**\n * Default filter, so default it does nothing at all to the values passed to it\n * e.g. max(1, 2, null, 4) would be max(1, 2, null, 4)\n */\n\n/**\n *  Copyright (c) 2015-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar keepMissing = function keepMissing(values) {\n  return values;\n};\n/**\n * Removes missing values (null, undefined or NaN) from the list of\n * values passed into the aggregation function \n * e.g. avg(1, 2, null, 4) would be avg(1, 2, 4)\n */\n\n\nvar ignoreMissing = function ignoreMissing(values) {\n  return values.filter(isValid);\n};\n/**\n * Replaces missing values (null, undefined or NaN) by 0.\n * e.g. avg(1, 2, null, 4) would be avg(1, 2, 0, 4)\n */\n\n\nvar zeroMissing = function zeroMissing(values) {\n  return values.map(function (v) {\n    return isValid(v) ? v : 0;\n  });\n};\n/**\n * If there are missing values in the list of values being\n * aggregated then the result of the aggregation should be\n * also undefined or null.\n * e.g. avg(2, 4, null, 7) would be null.\n */\n\n\nvar propagateMissing = function propagateMissing(values) {\n  return ignoreMissing(values).length === values.length ? values : null;\n};\n/**\n * If there are no values in the list, the result of the aggregation\n * is null \n */\n\n\nvar noneIfEmpty = function noneIfEmpty(values) {\n  return values.length === 0 ? null : values;\n};\n\nvar filter = exports.filter = {\n  keepMissing: keepMissing,\n  ignoreMissing: ignoreMissing,\n  zeroMissing: zeroMissing,\n  propagateMissing: propagateMissing,\n  noneIfEmpty: noneIfEmpty\n};\n/**\n * Like first() except it will return null if not all the values are\n * the same. This can be used to transfer a value when doing aggregation.\n * For instance you might group by the 'type', then avg the 'value', but\n * you want to results to include the type. So you would 'keep' the type\n * and 'avg' the value.\n */\n\nfunction keep() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var result = first()(cleanValues);\n    cleanValues.forEach(function (v) {\n      if (v !== result) {\n        return null;\n      }\n    });\n    return result;\n  };\n}\n/**\n * Returns a sum function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the sum calculation. Other possibilities are:\n *     `propergateMissing` - which will cause the min itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction sum() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return _underscore2.default.reduce(cleanValues, function (a, b) {\n      return a + b;\n    }, 0);\n  };\n}\n/**\n * Returns a avg function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the average calculation. Other possibilities are:\n *     `propergateMissing` - which will cause the avg itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction avg() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n\n    var sum = _underscore2.default.reduce(cleanValues, function (a, b) {\n      return a + b;\n    }, 0);\n\n    return sum / cleanValues.length;\n  };\n}\n/**\n * Return a max function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the maximum search. Other possibilities are:\n *     `propergateMissing` - which will cause the max itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction max() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n\n    var max = _underscore2.default.max(cleanValues);\n\n    if (_underscore2.default.isFinite(max)) {\n      return max;\n    }\n  };\n}\n/**\n * Return a min function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the minimum search. Other possibilities are:\n *     `propergateMissing` - which will cause the min itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction min() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n\n    var min = _underscore2.default.min(cleanValues);\n\n    if (_underscore2.default.isFinite(min)) {\n      return min;\n    }\n  };\n}\n/**\n * Returns a count() function.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the count. Other possibilities are:\n *     `propergateMissing` - which will cause the count itself to\n *     be null if the values contain a missing value\n */\n\n\nfunction count() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return cleanValues.length;\n  };\n}\n/**\n * Returns a first() function, i.e. a function that returns the first\n * value in the supplied values list.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the list, i.e to find the first non-missing value. Other\n * possibilities are:\n *     `keepMissing` - to return the first value, regardless of if\n *     it is a missing value or not.\n */\n\n\nfunction first() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return cleanValues.length ? cleanValues[0] : undefined;\n  };\n}\n/**\n * Returns a last() function, i.e. a function that returns the list\n * value in the supplied values list.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the list, i.e to find the last non-missing value. Other\n * possibilities are:\n *     `keepMissing` - to return the last value, regardless of if\n *     it is a missing value or not.\n */\n\n\nfunction last() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return cleanValues.length ? cleanValues[cleanValues.length - 1] : undefined;\n  };\n}\n/**\n * Returns a difference() function, i.e. a function that returns\n * the difference between the min and max values.\n *\n * Optionally you can specify the method by which unclean values\n * are treated. The default is to exclude missing values from\n * the list, i.e to find the last non-missing value. Other\n * possibilities are:\n *     `propergateMissing` - which will cause the min itself to\n *     be null if the values contain a missing value\n *     `zeroMissing` - will replace missing values with a zero\n */\n\n\nfunction difference() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    return _underscore2.default.max(cleanValues) - _underscore2.default.min(cleanValues);\n  };\n}\n\nfunction median() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var sorted = cleanValues.sort();\n    var i = Math.floor(sorted.length / 2);\n\n    if (sorted.length % 2 === 0) {\n      var a = sorted[i];\n      var b = sorted[i - 1];\n      return (a + b) / 2;\n    } else {\n      return sorted[i];\n    }\n  };\n}\n\nfunction stdev() {\n  var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var sums = 0;\n    var mean = avg(clean)(cleanValues);\n    cleanValues.forEach(function (v) {\n      return sums += Math.pow(v - mean, 2);\n    });\n    return Math.sqrt(sums / values.length);\n  };\n}\n/**\n * Returns a percentile function within the a values list.\n *\n * @param  {object}  options  The parameters controlling the function:\n *                             * q        The percentile (should be between 0 and 100)\n *                             * interp   Specifies the interpolation method\n *                                        to use when the desired quantile lies between\n *                                        two data points. Options are:\n *                                          * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n *                                          * lower: i.\n *                                          * higher: j.\n *                                          * nearest: i or j whichever is nearest.\n *                                          * midpoint: (i + j) / 2.\n *                             * clean    Strategy to use when encountering missing data:\n *                                          * `propergateMissing` - which will cause the min\n *                                             itself to be null if the values contain a\n *                                             missing value\n *                                          * `zeroMissing` - will replace missing values\n *                                             with a zero\n * @return {number}            The percentile\n */\n\n\nfunction percentile(q) {\n  var interp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"linear\";\n  var clean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : filter.ignoreMissing;\n  return function (values) {\n    var cleanValues = clean(values);\n    if (!cleanValues) return null;\n    var v = void 0;\n    var sorted = cleanValues.slice().sort(function (a, b) {\n      return a - b;\n    });\n    var size = sorted.length;\n\n    if (q < 0 || q > 100) {\n      throw new Error(\"Percentile q must be between 0 and 100\");\n    }\n\n    var i = q / 100;\n    var index = Math.floor((sorted.length - 1) * i);\n\n    if (size === 1 || q === 0) {\n      return sorted[0];\n    }\n\n    if (q === 100) {\n      return sorted[size - 1];\n    }\n\n    if (index < size - 1) {\n      var fraction = (size - 1) * i - index;\n      var v0 = sorted[index];\n      var v1 = sorted[index + 1];\n\n      if (interp === \"lower\" || fraction === 0) {\n        v = v0;\n      } else if (interp === \"linear\") {\n        v = v0 + (v1 - v0) * fraction;\n      } else if (interp === \"higher\") {\n        v = v1;\n      } else if (interp === \"nearest\") {\n        v = fraction < 0.5 ? v0 : v1;\n      } else if (interp === \"midpoint\") {\n        v = (v0 + v1) / 2;\n      }\n    }\n\n    return v;\n  };\n}","map":null,"metadata":{},"sourceType":"script"}