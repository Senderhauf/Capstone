{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _d3Shape = require(\"d3-shape\");\n\nvar _merge = require(\"merge\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _pondjs = require(\"pondjs\");\n\nvar _styler = require(\"../js/styler\");\n\nvar _util = require(\"../js/util\");\n\nvar _curve = require(\"../js/curve\");\n\nvar _curve2 = _interopRequireDefault(_curve);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n *  Copyright (c) 2015-present, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar defaultStyle = {\n  normal: {\n    stroke: \"steelblue\",\n    fill: \"none\",\n    strokeWidth: 1\n  },\n  highlighted: {\n    stroke: \"#5a98cb\",\n    fill: \"none\",\n    strokeWidth: 1\n  },\n  selected: {\n    stroke: \"steelblue\",\n    fill: \"none\",\n    strokeWidth: 2\n  },\n  muted: {\n    stroke: \"steelblue\",\n    fill: \"none\",\n    opacity: 0.4,\n    strokeWidth: 1\n  }\n};\n/**\n * The `<LineChart>` component is able to display multiple columns of a TimeSeries\n * as separate line charts.\n *\n * The `<LineChart>` should be used within `<ChartContainer>` etc., as this will\n * construct the horizontal and vertical axis, and manage other elements.\n *\n * Here is an example of two columns of a TimeSeries being plotted with the `<LineChart>`:\n *\n * ```\n  <ChartContainer timeRange={this.state.timerange} >\n    <ChartRow height=\"200\">\n      <YAxis id=\"y\" label=\"Price ($)\" min={0.5} max={1.5} format=\"$,.2f\" />\n      <Charts>\n        <LineChart\n          axis=\"y\"\n          breakLine={false}\n          series={currencySeries}\n          columns={[\"aud\", \"euro\"]}\n          style={style}\n          interpolation=\"curveBasis\" />\n      </Charts>\n    </ChartRow>\n  </ChartContainer>\n * ```\n */\n\nvar LineChart = function (_React$Component) {\n  _inherits(LineChart, _React$Component);\n\n  function LineChart() {\n    _classCallCheck(this, LineChart);\n\n    return _possibleConstructorReturn(this, (LineChart.__proto__ || Object.getPrototypeOf(LineChart)).apply(this, arguments));\n  }\n\n  _createClass(LineChart, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      var newSeries = nextProps.series;\n      var oldSeries = this.props.series;\n      var width = nextProps.width;\n      var timeScale = nextProps.timeScale;\n      var yScale = nextProps.yScale;\n      var interpolation = nextProps.interpolation;\n      var highlight = nextProps.highlight;\n      var selection = nextProps.selection;\n      var columns = nextProps.columns; // What changed?\n\n      var widthChanged = this.props.width !== width;\n      var timeScaleChanged = (0, _util.scaleAsString)(this.props.timeScale) !== (0, _util.scaleAsString)(timeScale);\n      var yAxisScaleChanged = this.props.yScale !== yScale;\n      var interpolationChanged = this.props.interpolation !== interpolation;\n      var highlightChanged = this.props.highlight !== highlight;\n      var selectionChanged = this.props.selection !== selection;\n      var columnsChanged = this.props.columns !== columns;\n      var seriesChanged = false;\n\n      if (oldSeries.size() !== newSeries.size()) {\n        seriesChanged = true;\n      } else {\n        seriesChanged = !_pondjs.TimeSeries.is(oldSeries, newSeries);\n      }\n\n      return widthChanged || seriesChanged || timeScaleChanged || yAxisScaleChanged || interpolationChanged || highlightChanged || selectionChanged || columnsChanged;\n    }\n  }, {\n    key: \"handleHover\",\n    value: function handleHover(e, column) {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(column);\n      }\n    }\n  }, {\n    key: \"handleHoverLeave\",\n    value: function handleHoverLeave() {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(null);\n      }\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e, column) {\n      e.stopPropagation();\n\n      if (this.props.onSelectionChange) {\n        this.props.onSelectionChange(column);\n      }\n    }\n  }, {\n    key: \"providedPathStyleMap\",\n    value: function providedPathStyleMap(column) {\n      var style = {};\n\n      if (this.props.style) {\n        if (this.props.style instanceof _styler.Styler) {\n          style = this.props.style.lineChartStyle()[column];\n        } else if (_underscore2.default.isFunction(this.props.style)) {\n          style = this.props.style(column);\n        } else if (_underscore2.default.isObject(this.props.style)) {\n          style = this.props.style ? this.props.style[column] : defaultStyle;\n        }\n      }\n\n      return style;\n    }\n    /**\n     * Returns the style used for drawing the path\n     */\n\n  }, {\n    key: \"pathStyle\",\n    value: function pathStyle(column) {\n      var style = void 0;\n      var styleMap = this.providedPathStyleMap(column);\n      var isHighlighted = this.props.highlight && column === this.props.highlight;\n      var isSelected = this.props.selection && column === this.props.selection;\n\n      if (this.props.selection) {\n        if (isSelected) {\n          style = (0, _merge2.default)(true, defaultStyle.selected, styleMap.selected ? styleMap.selected : {});\n        } else if (isHighlighted) {\n          style = (0, _merge2.default)(true, defaultStyle.highlighted, styleMap.highlighted ? styleMap.highlighted : {});\n        } else {\n          style = (0, _merge2.default)(true, defaultStyle.muted, styleMap.muted ? styleMap.muted : {});\n        }\n      } else if (isHighlighted) {\n        style = (0, _merge2.default)(true, defaultStyle.highlighted, styleMap.highlighted ? styleMap.highlighted : {});\n      } else {\n        style = (0, _merge2.default)(true, defaultStyle.normal, styleMap.normal);\n      }\n\n      style.pointerEvents = \"none\";\n      return style;\n    }\n  }, {\n    key: \"renderPath\",\n    value: function renderPath(data, column, key) {\n      var _this2 = this;\n\n      var hitStyle = {\n        stroke: \"white\",\n        fill: \"none\",\n        opacity: 0.0,\n        strokeWidth: 7,\n        cursor: \"crosshair\",\n        pointerEvents: \"stroke\"\n      }; // D3 generates each path\n\n      var path = (0, _d3Shape.line)().curve(_curve2.default[this.props.interpolation]).x(function (d) {\n        return _this2.props.timeScale(d.x);\n      }).y(function (d) {\n        return _this2.props.yScale(d.y);\n      })(data);\n      return _react2.default.createElement(\"g\", {\n        key: key\n      }, _react2.default.createElement(\"path\", {\n        d: path,\n        style: this.pathStyle(column)\n      }), _react2.default.createElement(\"path\", {\n        d: path,\n        style: hitStyle,\n        onClick: function onClick(e) {\n          return _this2.handleClick(e, column);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this2.handleHoverLeave();\n        },\n        onMouseMove: function onMouseMove(e) {\n          return _this2.handleHover(e, column);\n        }\n      }));\n    }\n  }, {\n    key: \"renderLines\",\n    value: function renderLines() {\n      var _this3 = this;\n\n      return _underscore2.default.map(this.props.columns, function (column) {\n        return _this3.renderLine(column);\n      });\n    }\n  }, {\n    key: \"renderLine\",\n    value: function renderLine(column) {\n      var pathLines = [];\n      var count = 1;\n\n      if (this.props.breakLine) {\n        // Remove nulls and NaNs from the line by generating a break in the line\n        var currentPoints = null;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.props.series.events()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var d = _step.value;\n            var timestamp = new Date(d.begin().getTime() + (d.end().getTime() - d.begin().getTime()) / 2);\n            var value = d.get(column);\n            var badPoint = _underscore2.default.isNull(value) || _underscore2.default.isNaN(value) || !_underscore2.default.isFinite(value);\n\n            if (!badPoint) {\n              if (!currentPoints) currentPoints = [];\n              currentPoints.push({\n                x: timestamp,\n                y: value\n              });\n            } else if (currentPoints) {\n              if (currentPoints.length > 1) {\n                pathLines.push(this.renderPath(currentPoints, column, count));\n                count += 1;\n              }\n\n              currentPoints = null;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (currentPoints && currentPoints.length > 1) {\n          pathLines.push(this.renderPath(currentPoints, column, count));\n          count += 1;\n        }\n      } else {\n        // Ignore nulls and NaNs in the line\n        var cleanedPoints = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.props.series.events()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _d = _step2.value;\n\n            var _timestamp = new Date(_d.begin().getTime() + (_d.end().getTime() - _d.begin().getTime()) / 2);\n\n            var _value = _d.get(column);\n\n            var _badPoint = _underscore2.default.isNull(_value) || _underscore2.default.isNaN(_value) || !_underscore2.default.isFinite(_value);\n\n            if (!_badPoint) {\n              cleanedPoints.push({\n                x: _timestamp,\n                y: _value\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        pathLines.push(this.renderPath(cleanedPoints, column, count));\n        count += 1;\n      }\n\n      return _react2.default.createElement(\"g\", {\n        key: column\n      }, pathLines);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react2.default.createElement(\"g\", null, this.renderLines());\n    }\n  }]);\n\n  return LineChart;\n}(_react2.default.Component);\n\nexports.default = LineChart;\nLineChart.propTypes = {\n  /**\n   * Show or hide this chart\n   */\n  visible: _propTypes2.default.bool,\n\n  /**\n   * What [Pond TimeSeries](https://esnet-pondjs.appspot.com/#/timeseries) data to visualize\n   */\n  series: _propTypes2.default.instanceOf(_pondjs.TimeSeries).isRequired,\n\n  /**\n   * Reference to the axis which provides the vertical scale for drawing.\n   * e.g. specifying `axis=\"trafficRate\"` would refer the y-scale of the YAxis\n   * with id=\"trafficRate\".\n   */\n  axis: _propTypes2.default.string.isRequired,\n  // eslint-disable-line\n\n  /**\n   * Which columns from the series to draw.\n   *\n   * NOTE : Columns can't have periods because periods\n   * represent a path to deep data in the underlying events\n   * (i.e. reference into nested data structures)\n   */\n  columns: _propTypes2.default.arrayOf(_propTypes2.default.string),\n\n  /**\n   * The styles to apply to the underlying SVG lines. This is a mapping\n   * of column names to objects with style attributes, in the following\n   * format:\n   *\n   * ```\n   * const style = {\n   *     in: {\n   *         normal: {stroke: \"steelblue\", fill: \"none\", strokeWidth: 1},\n   *         highlighted: {stroke: \"#5a98cb\", fill: \"none\", strokeWidth: 1},\n   *         selected: {stroke: \"steelblue\", fill: \"none\", strokeWidth: 1},\n   *         muted: {stroke: \"steelblue\", fill: \"none\", opacity: 0.4, strokeWidth: 1}\n   *     },\n   *     out: {\n   *         ...\n   *     }\n   * };\n   *\n   *  <LineChart style={style} ... />\n   * ```\n   *\n   * Alternatively, you can pass in a `Styler`. For example:\n   *\n   * ```\n   * const currencyStyle = Styler([\n   *     {key: \"aud\", color: \"steelblue\", width: 1, dashed: true},\n   *     {key: \"euro\", color: \"#F68B24\", width: 2}\n   * ]);\n   *\n   * <LineChart columns={[\"aud\", \"euro\"]} style={currencyStyle} ... />\n   *\n   * ```\n   */\n  style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func, _propTypes2.default.instanceOf(_styler.Styler)]),\n\n  /**\n   * Any of D3's interpolation modes.\n   */\n  interpolation: _propTypes2.default.oneOf([\"curveBasis\", \"curveBasisOpen\", \"curveBundle\", \"curveCardinal\", \"curveCardinalOpen\", \"curveCatmullRom\", \"curveCatmullRomOpen\", \"curveLinear\", \"curveMonotoneX\", \"curveMonotoneY\", \"curveNatural\", \"curveRadial\", \"curveStep\", \"curveStepAfter\", \"curveStepBefore\"]),\n\n  /**\n   * The determines how to handle bad/missing values in the supplied\n   * TimeSeries. A missing value can be null or NaN. If breakLine\n   * is set to true (the default) then the line will be broken on either\n   * side of the bad value(s). If breakLine is false bad values\n   * are simply removed and the adjoining points are connected.\n   */\n  breakLine: _propTypes2.default.bool,\n\n  /**\n   * The selected item, which will be rendered in the \"selected\" style.\n   * If a line is selected, all other lines will be rendered in the \"muted\" style.\n   *\n   * See also `onSelectionChange`\n   */\n  selection: _propTypes2.default.string,\n\n  /**\n   * A callback that will be called when the selection changes. It will be called\n   * with the column corresponding to the line being clicked.\n   */\n  onSelectionChange: _propTypes2.default.func,\n\n  /**\n   * The highlighted column, which will be rendered in the \"highlighted\" style.\n   *\n   * See also `onHighlightChange`\n   */\n  highlight: _propTypes2.default.string,\n\n  /**\n   * A callback that will be called when the hovered over line changes.\n   * It will be called with the corresponding column.\n   */\n  onHighlightChange: _propTypes2.default.func,\n\n  /**\n   * [Internal] The timeScale supplied by the surrounding ChartContainer\n   */\n  timeScale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The yScale supplied by the associated YAxis\n   */\n  yScale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The width supplied by the surrounding ChartContainer\n   */\n  width: _propTypes2.default.number\n};\nLineChart.defaultProps = {\n  visible: true,\n  columns: [\"value\"],\n  smooth: true,\n  interpolation: \"curveLinear\",\n  breakLine: true\n};","map":null,"metadata":{},"sourceType":"script"}