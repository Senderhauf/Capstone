{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n/**\n *  Copyright (c) 2015, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar ScaleInterpolator = function () {\n  function ScaleInterpolator(transition, ease, observer) {\n    _classCallCheck(this, ScaleInterpolator);\n\n    this.id = _underscore2.default.uniqueId(\"scaler\");\n    this.ease = ease;\n    this.transitionTime = transition;\n    this.observer = observer;\n    this.sourceScale = null;\n    this.targetScale = null;\n    this.cachedScaler = null;\n    this.cacheKey = null;\n  }\n\n  _createClass(ScaleInterpolator, [{\n    key: \"update\",\n    value: function update() {\n      var _this = this;\n\n      var animationTime = 0;\n\n      if (!this.initialTimestamp) {\n        this.initialTimestamp = window.performance.now();\n      } else {\n        animationTime = window.performance.now() - this.initialTimestamp;\n      }\n\n      var animationPosition = this.transitionTime ? Math.min(animationTime / this.transitionTime, 1.0) : 1.0;\n\n      if (!this.targetScale) {\n        return;\n      }\n\n      if (this.observer) {\n        var func1 = this.sourceScale;\n        var func2 = this.targetScale;\n        var te = this.ease(animationPosition);\n\n        var scaler = function scaler(x) {\n          var a = func1(x);\n          var b = func2(x);\n          return a + (b - a) * te;\n        };\n\n        this.observer(scaler);\n      }\n\n      if (animationPosition < 1.0) {\n        // keep animating\n        setTimeout(function () {\n          return _this.update();\n        }, 20);\n      } else {\n        // reset\n        this.sourceScale = this.targetScale;\n        this.targetScale = null;\n        this.initialTimestamp = null;\n      }\n    }\n    /**\n     * A new (or initial) scale is set on the interpolator\n     */\n\n  }, {\n    key: \"setScale\",\n    value: function setScale(key, scale) {\n      var _this2 = this; // Initial scale\n\n\n      if (!this.sourceScale) {\n        this.sourceScale = scale;\n        return;\n      } //\n      //  If there was already a scale, and a new scale is set\n      // the this begins an animation across between the two\n      // scales, assuming a transition time is provided. To do\n      // this we set the new scale as the target and reset the\n      // t to 0. (if there's no transition, jump to t = 1)\n      //\n\n\n      if (key !== this.cacheKey) {\n        this.targetScale = scale;\n        this.cachedScaler = null;\n        this.initialTimestamp = null;\n        setTimeout(function () {\n          return _this2.update();\n        }, 0);\n      }\n\n      this.cacheKey = key;\n    }\n    /**\n     * Returns a scaler, which is a function that scales the value\n     * supplied to it. This return the scaler corresponding to the\n     * source scale. Note that if a target scale is defined and the\n     * interpolator is animating towards that target, the observer\n     * callback will be called with the transitional scaler that can\n     * be used to scale data to the intermediate state.\n     */\n\n  }, {\n    key: \"scaler\",\n    value: function scaler() {\n      var _this3 = this;\n\n      if (_underscore2.default.isNull(this.cachedScaler)) {\n        this.cachedScaler = function (v) {\n          return _this3.sourceScale(v);\n        };\n      }\n\n      return this.cachedScaler;\n    }\n    /**\n     * Returns the d3 scale. It will return the target scale if present\n     * otherwise the source scale. Note: this is the d3 internal scale. To\n     * scale values, use the scaler.\n     */\n\n  }, {\n    key: \"latestScale\",\n    value: function latestScale() {\n      return this.targetScale ? this.targetScale : this.sourceScale;\n    }\n    /**\n     * Returns the transition, as set in the constructor\n     */\n\n  }, {\n    key: \"transition\",\n    value: function transition() {\n      return this.transitionTime;\n    }\n  }]);\n\n  return ScaleInterpolator;\n}();\n\nexports.default = ScaleInterpolator;","map":null,"metadata":{},"sourceType":"script"}