{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isInteger = require(\"babel-runtime/core-js/number/is-integer\");\n\nvar _isInteger2 = _interopRequireDefault(_isInteger);\n\nvar _getPrototypeOf = require(\"babel-runtime/core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _immutable = require(\"immutable\");\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nvar _index = require(\"../index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _indexedevent = require(\"../indexedevent\");\n\nvar _indexedevent2 = _interopRequireDefault(_indexedevent);\n\nvar _processor = require(\"./processor\");\n\nvar _processor2 = _interopRequireDefault(_processor);\n\nvar _timeevent = require(\"../timeevent\");\n\nvar _timeevent2 = _interopRequireDefault(_timeevent);\n\nvar _timerange = require(\"../timerange\");\n\nvar _timerange2 = _interopRequireDefault(_timerange);\n\nvar _timerangeevent = require(\"../timerangeevent\");\n\nvar _timerangeevent2 = _interopRequireDefault(_timerangeevent);\n\nvar _pipeline = require(\"../pipeline\");\n\nvar _util = require(\"../base/util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A processor to align the data into bins of regular time period.\n */\n\n/**\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/*eslint no-console: 0 */\n\n\nvar Aligner = function (_Processor) {\n  (0, _inherits3.default)(Aligner, _Processor);\n\n  function Aligner(arg1, options) {\n    (0, _classCallCheck3.default)(this, Aligner);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Aligner.__proto__ || (0, _getPrototypeOf2.default)(Aligner)).call(this, arg1, options));\n\n    if (arg1 instanceof Aligner) {\n      var other = arg1;\n      _this._fieldSpec = other._fieldSpec;\n      _this._window = other._window;\n      _this._method = other._method;\n      _this._limit = other._limit;\n    } else if ((0, _pipeline.isPipeline)(arg1)) {\n      var fieldSpec = options.fieldSpec,\n          window = options.window,\n          _options$method = options.method,\n          method = _options$method === undefined ? \"hold\" : _options$method,\n          _options$limit = options.limit,\n          limit = _options$limit === undefined ? null : _options$limit;\n      _this._fieldSpec = fieldSpec;\n      _this._window = window;\n      _this._method = method;\n      _this._limit = limit;\n    } else {\n      throw new Error(\"Unknown arg to Aligner constructor\", arg1);\n    } //\n    // Internal members\n    //\n\n\n    _this._previous = null; // work out field specs\n\n    if (_underscore2.default.isString(_this._fieldSpec)) {\n      _this._fieldSpec = [_this._fieldSpec];\n    } // check input of method\n\n\n    if (!_underscore2.default.contains([\"linear\", \"hold\"], _this._method)) {\n      throw new Error(\"Unknown method '\" + _this._method + \"' passed to Aligner\");\n    } // check limit\n\n\n    if (_this._limit && !(0, _isInteger2.default)(_this._limit)) {\n      throw new Error(\"Limit passed to Aligner is not an integer\");\n    }\n\n    return _this;\n  }\n\n  (0, _createClass3.default)(Aligner, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Aligner(this);\n    }\n    /**\n     * Test to see if an event is perfectly aligned. Used on first event.\n     */\n\n  }, {\n    key: \"isAligned\",\n    value: function isAligned(event) {\n      var bound = _index2.default.getIndexString(this._window, event.timestamp());\n\n      return this.getBoundaryTime(bound) === event.timestamp().getTime();\n    }\n    /**\n     * Returns a list of indexes of window boundaries if the current\n     * event and the previous event do not lie in the same window. If\n     * they are in the same window, return an empty list.\n     */\n\n  }, {\n    key: \"getBoundaries\",\n    value: function getBoundaries(event) {\n      var prevIndex = _index2.default.getIndexString(this._window, this._previous.timestamp());\n\n      var currentIndex = _index2.default.getIndexString(this._window, event.timestamp());\n\n      if (prevIndex !== currentIndex) {\n        var range = new _timerange2.default(this._previous.timestamp(), event.timestamp());\n        return _index2.default.getIndexStringList(this._window, range).slice(1);\n      } else {\n        return [];\n      }\n    }\n    /**\n     * We are dealing in UTC only with the Index because the events\n     * all have internal timestamps in UTC and that's what we're\n     * aligning. Let the user display in local time if that's\n     * what they want.\n     */\n\n  }, {\n    key: \"getBoundaryTime\",\n    value: function getBoundaryTime(boundaryIndex) {\n      var index = new _index2.default(boundaryIndex);\n      return index.begin().getTime();\n    }\n    /**\n     * Generate a new event on the requested boundary and carry over the\n     * value from the previous event.\n     *\n     * A variation just sets the values to null, this is used when the\n     * limit is hit.\n     */\n\n  }, {\n    key: \"interpolateHold\",\n    value: function interpolateHold(boundary) {\n      var _this2 = this;\n\n      var setNone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var d = new _immutable2.default.Map();\n      var t = this.getBoundaryTime(boundary);\n\n      this._fieldSpec.forEach(function (path) {\n        var fieldPath = _util2.default.fieldPathToArray(path);\n\n        if (!setNone) {\n          d = d.setIn(fieldPath, _this2._previous.get(fieldPath));\n        } else {\n          d = d.setIn(fieldPath, null);\n        }\n      });\n\n      return new _timeevent2.default(t, d);\n    }\n    /**\n      * Generate a linear differential between two counter values that lie\n      * on either side of a window boundary.\n      */\n\n  }, {\n    key: \"interpolateLinear\",\n    value: function interpolateLinear(boundary, event) {\n      var _this3 = this;\n\n      var d = new _immutable2.default.Map();\n\n      var previousTime = this._previous.timestamp().getTime();\n\n      var boundaryTime = this.getBoundaryTime(boundary);\n      var currentTime = event.timestamp().getTime(); // This ratio will be the same for all values being processed\n\n      var f = (boundaryTime - previousTime) / (currentTime - previousTime);\n\n      this._fieldSpec.forEach(function (path) {\n        var fieldPath = _util2.default.fieldPathToArray(path); //\n        // Generate the delta beteen the values and\n        // bulletproof against non-numeric or bad paths\n        //\n\n\n        var previousVal = _this3._previous.get(fieldPath);\n\n        var currentVal = event.get(fieldPath);\n        var interpolatedVal = null;\n\n        if (!_underscore2.default.isNumber(previousVal) || !_underscore2.default.isNumber(currentVal)) {\n          console.warn(\"Path \" + fieldPath + \" contains a non-numeric value or does not exist\");\n        } else {\n          interpolatedVal = previousVal + f * (currentVal - previousVal);\n        }\n\n        d = d.setIn(fieldPath, interpolatedVal);\n      });\n\n      return new _timeevent2.default(boundaryTime, d);\n    }\n    /**\n     * Perform the fill operation on the event and emit.\n     */\n\n  }, {\n    key: \"addEvent\",\n    value: function addEvent(event) {\n      var _this4 = this;\n\n      if (event instanceof _timerangeevent2.default || event instanceof _indexedevent2.default) {\n        throw new Error(\"TimeRangeEvent and IndexedEvent series can not be aligned.\");\n      }\n\n      if (this.hasObservers()) {\n        if (!this._previous) {\n          this._previous = event;\n\n          if (this.isAligned(event)) {\n            this.emit(event);\n          }\n\n          return;\n        }\n\n        var boundaries = this.getBoundaries(event); //\n        // If the returned list is not empty, interpolate an event\n        // on each of the boundaries and emit them\n        //\n\n        var count = boundaries.length;\n        boundaries.forEach(function (boundary) {\n          var outputEvent = void 0;\n\n          if (_this4._limit && count > _this4._limit) {\n            outputEvent = _this4.interpolateHold(boundary, true);\n          } else {\n            if (_this4._method === \"linear\") {\n              outputEvent = _this4.interpolateLinear(boundary, event);\n            } else {\n              outputEvent = _this4.interpolateHold(boundary);\n            }\n          }\n\n          _this4.emit(outputEvent);\n        }); //\n        // The current event now becomes the previous event\n        //\n\n        this._previous = event;\n      }\n    }\n  }]);\n  return Aligner;\n}(_processor2.default);\n\nexports.default = Aligner;","map":null,"metadata":{},"sourceType":"script"}