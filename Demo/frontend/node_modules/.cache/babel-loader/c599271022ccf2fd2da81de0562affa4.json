{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _toConsumableArray2 = require(\"babel-runtime/helpers/toConsumableArray\");\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _getPrototypeOf = require(\"babel-runtime/core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _get2 = require(\"babel-runtime/helpers/get\");\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _processor = require(\"./processor\");\n\nvar _processor2 = _interopRequireDefault(_processor);\n\nvar _pipeline = require(\"../pipeline\");\n\nvar _util = require(\"../base/util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A processor that fills missing/invalid values in the event with\n * new values (zero, interpolated or padded).\n *\n * When doing a linear fill, Filler instances should be chained.\n *\n * If no fieldSpec is supplied, the default field \"value\" will be used.\n */\n\n/**\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/*eslint no-console: 0 */\n\n\nvar Filler = function (_Processor) {\n  (0, _inherits3.default)(Filler, _Processor);\n\n  function Filler(arg1, options) {\n    (0, _classCallCheck3.default)(this, Filler);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Filler.__proto__ || (0, _getPrototypeOf2.default)(Filler)).call(this, arg1, options));\n\n    if (arg1 instanceof Filler) {\n      var other = arg1;\n      _this._fieldSpec = other._fieldSpec;\n      _this._method = other._method;\n      _this._limit = other._limit;\n    } else if ((0, _pipeline.isPipeline)(arg1)) {\n      var _options$fieldSpec = options.fieldSpec,\n          fieldSpec = _options$fieldSpec === undefined ? null : _options$fieldSpec,\n          _options$method = options.method,\n          method = _options$method === undefined ? \"zero\" : _options$method,\n          _options$limit = options.limit,\n          limit = _options$limit === undefined ? null : _options$limit;\n      _this._fieldSpec = fieldSpec;\n      _this._method = method;\n      _this._limit = limit;\n    } else {\n      throw new Error(\"Unknown arg to Filler constructor\", arg1);\n    } //\n    // Internal members\n    //\n    // state for pad to refer to previous event\n\n\n    _this._previousEvent = null; // key count for zero and pad fill\n\n    _this._keyCount = {}; // special state for linear fill\n\n    _this._lastGoodLinear = null; // cache of events pending linear fill\n\n    _this._linearFillCache = []; //\n    // Sanity checks\n    //\n\n    if (!_underscore2.default.contains([\"zero\", \"pad\", \"linear\"], _this._method)) {\n      throw new Error(\"Unknown method \" + _this._method + \" passed to Filler\");\n    }\n\n    if (_this._limit && !_underscore2.default.isNumber(_this._limit)) {\n      throw new Error(\"Limit supplied to fill() should be a number\");\n    }\n\n    if (_underscore2.default.isString(_this._fieldSpec)) {\n      _this._fieldSpec = [_this._fieldSpec];\n    } else if (_underscore2.default.isNull(_this._fieldSpec)) {\n      _this._fieldSpec = [\"value\"];\n    } // Special case: when using linear mode, only a single\n    // column will be processed per instance\n\n\n    if (_this._method === \"linear\" && _this._fieldSpec.length > 1) {\n      throw new Error(\"Linear fill takes a path to a single column\");\n    }\n\n    return _this;\n  }\n\n  (0, _createClass3.default)(Filler, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Filler(this);\n    }\n    /**\n     * Process and fill the values at the paths as apropos when the fill\n     * method is either pad or zero.\n     */\n\n  }, {\n    key: \"constFill\",\n    value: function constFill(data) {\n      var newData = data;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)(this._fieldSpec), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var path = _step.value;\n\n          var fieldPath = _util2.default.fieldPathToArray(path);\n\n          var pathKey = fieldPath.join(\":\"); //initialize a counter for this column\n\n          if (!_underscore2.default.has(this._keyCount, pathKey)) {\n            this._keyCount[pathKey] = 0;\n          } // this is pointing at a path that does not exist\n\n\n          if (!newData.hasIn(fieldPath)) {\n            continue;\n          } // Get the next value using the fieldPath\n\n\n          var val = newData.getIn(fieldPath);\n\n          if (_util2.default.isMissing(val)) {\n            // Have we hit the limit?\n            if (this._limit && this._keyCount[pathKey] >= this._limit) {\n              continue;\n            }\n\n            if (this._method === \"zero\") {\n              // set to zero\n              newData = newData.setIn(fieldPath, 0);\n              this._keyCount[pathKey]++;\n            } else if (this._method === \"pad\") {\n              // set to previous value\n              if (!_underscore2.default.isNull(this._previousEvent)) {\n                var prevVal = this._previousEvent.data().getIn(fieldPath);\n\n                if (!_util2.default.isMissing(prevVal)) {\n                  newData = newData.setIn(fieldPath, prevVal);\n                  this._keyCount[pathKey]++;\n                }\n              }\n            } else if (this._method === \"linear\") {//noop\n            }\n          } else {\n            this._keyCount[pathKey] = 0;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return newData;\n    }\n    /**\n     * Check to see if an event has good values when doing\n     * linear fill since we need to keep a completely intact\n     * event for the values.\n     * While we are inspecting the data payload, make a note if\n     * any of the paths are pointing at a list. Then it\n     * will trigger that filling code later.\n     */\n\n  }, {\n    key: \"isValidLinearEvent\",\n    value: function isValidLinearEvent(event) {\n      var valid = true;\n\n      var fieldPath = _util2.default.fieldPathToArray(this._fieldSpec[0]); // Detect path that doesn't exist\n\n\n      if (!event.data().hasIn(fieldPath)) {\n        console.warn(\"path does not exist: \" + fieldPath);\n        return valid;\n      }\n\n      var val = event.data().getIn(fieldPath); // Detect if missing or not a number\n\n      if (_util2.default.isMissing(val) || !_underscore2.default.isNumber(val)) {\n        valid = false;\n      }\n\n      return valid;\n    }\n    /**\n     * This handles the linear filling. It returns a list of\n     * zero or more events to be emitted.\n     *\n     * If an event is valid - it has valid values for all of\n     * the field paths - it is cached as \"last good\" and\n     * returned to be emitted. The return value is then a list\n     * of one event.\n     *\n     * If an event has invalid values, it is cached to be\n     * processed later and an empty list is returned.\n     *\n     * Additional invalid events will continue to be cached until\n     * a new valid value is seen, then the cached events will\n     * be filled and returned. That will be a list of indeterminate\n     * length.\n     */\n\n  }, {\n    key: \"linearFill\",\n    value: function linearFill(event) {\n      var _this2 = this; // See if the event is valid and also if it has any\n      // list values to be filled.\n\n\n      var isValidEvent = this.isValidLinearEvent(event);\n      var events = [];\n\n      if (isValidEvent && !this._linearFillCache.length) {\n        // Valid event, no cached events, use as last good val\n        this._lastGoodLinear = event;\n        events.push(event);\n      } else if (!isValidEvent && !_underscore2.default.isNull(this._lastGoodLinear)) {\n        this._linearFillCache.push(event); // Check limit\n\n\n        if (!_underscore2.default.isNull(this._limit) && this._linearFillCache.length >= this._limit) {\n          // Flush the cache now because limit is reached\n          this._linearFillCache.forEach(function (e) {\n            _this2.emit(e);\n          }); // Reset\n\n\n          this._linearFillCache = [];\n          this._lastGoodLinear = null;\n        }\n      } else if (!isValidEvent && _underscore2.default.isNull(this._lastGoodLinear)) {\n        //\n        // An invalid event but we have not seen a good\n        // event yet so there is nothing to start filling \"from\"\n        // so just return and live with it.\n        //\n        events.push(event);\n      } else if (isValidEvent && this._linearFillCache) {\n        // Linear interpolation between last good and this event\n        var eventList = [this._lastGoodLinear].concat((0, _toConsumableArray3.default)(this._linearFillCache), [event]);\n        var interpolatedEvents = this.interpolateEventList(eventList); //\n        // The first event in the returned list from interpolatedEvents\n        // is our last good event. This event has already been emitted so\n        // it is sliced off.\n        //\n\n        interpolatedEvents.slice(1).forEach(function (e) {\n          events.push(e);\n        }); // Reset\n\n        this._linearFillCache = [];\n        this._lastGoodLinear = event;\n      }\n\n      return events;\n    }\n    /**\n     * The fundamental linear interpolation workhorse code.  Process\n     * a list of events and return a new list. Does a pass for\n     * every fieldSpec.\n     *\n     * This is abstracted out like this because we probably want\n     * to interpolate a list of events not tied to a Collection.\n     * A Pipeline result list, etc etc.\n     *\n    **/\n\n  }, {\n    key: \"interpolateEventList\",\n    value: function interpolateEventList(events) {\n      var prevValue = void 0;\n      var prevTime = void 0; // new array of interpolated events for each field path\n\n      var newEvents = [];\n\n      var fieldPath = _util2.default.fieldPathToArray(this._fieldSpec[0]); // setup done, loop through the events\n\n\n      for (var i = 0; i < events.length; i++) {\n        var e = events[i]; // Can't interpolate first or last event so just save it\n        // as is and move on.\n\n        if (i === 0) {\n          prevValue = e.get(fieldPath);\n          prevTime = e.timestamp().getTime();\n          newEvents.push(e);\n          continue;\n        }\n\n        if (i === events.length - 1) {\n          newEvents.push(e);\n          continue;\n        } // Detect non-numeric value\n\n\n        if (!_util2.default.isMissing(e.get(fieldPath)) && !_underscore2.default.isNumber(e.get(fieldPath))) {\n          console.warn(\"linear requires numeric values - skipping this field_spec\");\n          return events;\n        } // Found a missing value so start calculating.\n\n\n        if (_util2.default.isMissing(e.get(fieldPath))) {\n          // Find the next valid value in the original events\n          var ii = i + 1;\n          var nextValue = null;\n          var nextTime = null;\n\n          while (_underscore2.default.isNull(nextValue) && ii < events.length) {\n            var val = events[ii].get(fieldPath);\n\n            if (!_util2.default.isMissing(val)) {\n              nextValue = val; // exits loop\n\n              nextTime = events[ii].timestamp().getTime();\n            }\n\n            ii++;\n          } // Interpolate a new value to fill\n\n\n          if (!_underscore2.default.isNull(prevValue) && ~_underscore2.default.isNull(nextValue)) {\n            var currentTime = e.timestamp().getTime();\n\n            if (nextTime === prevTime) {\n              // If times are the same, just avg\n              var newValue = (prevValue + nextValue) / 2;\n              newEvents.push(e.setData(newValue));\n            } else {\n              var f = (currentTime - prevTime) / (nextTime - prevTime);\n\n              var _newValue = prevValue + f * (nextValue - prevValue);\n\n              var d = e.data().setIn(fieldPath, _newValue);\n              newEvents.push(e.setData(d));\n            }\n          } else {\n            newEvents.push(e);\n          }\n        } else {\n          newEvents.push(e);\n        }\n      }\n\n      return newEvents;\n    }\n    /**\n     * Perform the fill operation on the event and emit.\n     */\n\n  }, {\n    key: \"addEvent\",\n    value: function addEvent(event) {\n      if (this.hasObservers()) {\n        var emitList = [];\n        var d = event.data();\n\n        if (this._method === \"zero\" || this._method === \"pad\") {\n          var dd = this.constFill(d);\n          var e = event.setData(dd);\n          emitList.push(e);\n          this._previousEvent = e;\n        } else if (this._method === \"linear\") {\n          this.linearFill(event).forEach(function (e) {\n            emitList.push(e);\n          });\n        }\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = (0, _getIterator3.default)(emitList), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _event = _step2.value;\n            this.emit(_event);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this.hasObservers() && this._method == \"linear\") {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = (0, _getIterator3.default)(this._linearFillCache), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var event = _step3.value;\n            this.emit(event);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      (0, _get3.default)(Filler.prototype.__proto__ || (0, _getPrototypeOf2.default)(Filler.prototype), \"flush\", this).call(this);\n    }\n  }]);\n  return Filler;\n}(_processor2.default);\n\nexports.default = Filler;","map":null,"metadata":{},"sourceType":"script"}