{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = require(\"babel-runtime/helpers/slicedToArray\");\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _toConsumableArray2 = require(\"babel-runtime/helpers/toConsumableArray\");\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _immutable = require(\"immutable\");\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nvar _moment = require(\"moment\");\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _timerange = require(\"../timerange\");\n\nvar _timerange2 = _interopRequireDefault(_timerange);\n\nvar _index = require(\"../index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar units = {\n  s: {\n    label: \"seconds\",\n    length: 1\n  },\n  m: {\n    label: \"minutes\",\n    length: 60\n  },\n  h: {\n    label: \"hours\",\n    length: 60 * 60\n  },\n  d: {\n    label: \"days\",\n    length: 60 * 60 * 24\n  }\n};\n/**\n * This function will take an index, which may be of two forms:\n *     2015-07-14  (day)\n *     2015-07     (month)\n *     2015        (year)\n * or:\n *     1d-278      (range, in n x days, hours, minutes or seconds)\n *\n * and return a TimeRange for that time. The TimeRange may be considered to be\n * local time or UTC time, depending on the utc flag passed in.\n */\n\n/**\n *  Copyright (c) 2015-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\nexports.default = {\n  /**\n   * Single zero left padding, for days and months.\n   */\n  leftPad: function leftPad(value) {\n    return \"\" + (value < 10 ? \"0\" : \"\") + value;\n  },\n\n  /**\n   * Returns a duration in milliseconds given a window duration string.\n   * For example \"30s\" (30 seconds) should return 30000ms. Accepts\n   * seconds (e.g. \"30s\"), minutes (e.g. \"5m\"), hours (e.g. \"6h\") and\n   * days (e.g. \"30d\")\n   */\n  windowDuration: function windowDuration(w) {\n    // window should be two parts, a number and a letter if it's a\n    // range based index, e.g \"1h\".\n    var regex = /([0-9]+)([smhd])/;\n    var parts = regex.exec(w);\n\n    if (parts && parts.length >= 3) {\n      var num = parseInt(parts[1], 10);\n      var unit = parts[2];\n      return num * units[unit].length * 1000;\n    }\n  },\n  windowPositionFromDate: function windowPositionFromDate(w, date) {\n    var duration = this.windowDuration(w);\n\n    var dd = _moment2.default.utc(date).valueOf();\n\n    return parseInt(dd /= duration, 10);\n  },\n  rangeFromIndexString: function rangeFromIndexString(index, utc) {\n    var isUTC = !_underscore2.default.isUndefined(utc) ? utc : true;\n    var parts = index.split(\"-\");\n    var beginTime = void 0;\n    var endTime = void 0;\n\n    switch (parts.length) {\n      case 3:\n        // A day, month and year e.g. 2014-10-24\n        if (!_underscore2.default.isNaN(parseInt(parts[0], 10)) && !_underscore2.default.isNaN(parseInt(parts[1], 10)) && !_underscore2.default.isNaN(parseInt(parts[2], 10))) {\n          var _year = parseInt(parts[0], 10);\n\n          var month = parseInt(parts[1], 10);\n          var day = parseInt(parts[2], 10);\n          beginTime = isUTC ? _moment2.default.utc([_year, month - 1, day]) : (0, _moment2.default)([_year, month - 1, day]);\n          endTime = isUTC ? _moment2.default.utc(beginTime).endOf(\"day\") : (0, _moment2.default)(beginTime).endOf(\"day\");\n        }\n\n        break;\n\n      case 2:\n        // Size should be two parts, a number and a letter if it's a\n        // range based index, e.g 1h-23478\n        var rangeRegex = /([0-9]+)([smhd])/;\n        var sizeParts = rangeRegex.exec(parts[0]);\n\n        if (sizeParts && sizeParts.length >= 3 && !_underscore2.default.isNaN(parseInt(parts[1], 10))) {\n          var pos = parseInt(parts[1], 10);\n          var num = parseInt(sizeParts[1], 10);\n          var unit = sizeParts[2];\n          var length = num * units[unit].length * 1000;\n          beginTime = isUTC ? _moment2.default.utc(pos * length) : (0, _moment2.default)(pos * length);\n          endTime = isUTC ? _moment2.default.utc((pos + 1) * length) : (0, _moment2.default)((pos + 1) * length); // A month and year e.g 2015-09\n        } else if (!_underscore2.default.isNaN(parseInt(parts[0], 10)) && !_underscore2.default.isNaN(parseInt(parts[1], 10))) {\n          var _year2 = parseInt(parts[0], 10);\n\n          var _month = parseInt(parts[1], 10);\n\n          beginTime = isUTC ? _moment2.default.utc([_year2, _month - 1]) : (0, _moment2.default)([_year2, _month - 1]);\n          endTime = isUTC ? _moment2.default.utc(beginTime).endOf(\"month\") : (0, _moment2.default)(beginTime).endOf(\"month\");\n        }\n\n        break;\n      // A year e.g. 2015\n\n      case 1:\n        var year = parts[0];\n        beginTime = isUTC ? _moment2.default.utc([year]) : (0, _moment2.default)([year]);\n        endTime = isUTC ? _moment2.default.utc(beginTime).endOf(\"year\") : (0, _moment2.default)(beginTime).endOf(\"year\");\n        break;\n    }\n\n    if (beginTime && beginTime.isValid() && endTime && endTime.isValid()) {\n      return new _timerange2.default(beginTime, endTime);\n    } else {\n      return undefined;\n    }\n  },\n\n  /**\n   * Returns a nice string for the index. If the index is of the form\n   * 1d-2345 then just that string is returned (there's not nice way to put\n   * it), but if it represents a day, month, or year (e.g. 2015-07) then a\n   * nice string like \"July\" will be returned. It's also possible to pass in\n   * the format of the reply for these types of strings. See moment's format\n   * naming conventions:\n   * http://momentjs.com/docs/#/displaying/format/\n   */\n  niceIndexString: function niceIndexString(index, format) {\n    var t = void 0;\n    var parts = index.split(\"-\");\n\n    switch (parts.length) {\n      case 3:\n        if (!_underscore2.default.isNaN(parseInt(parts[0], 10)) && !_underscore2.default.isNaN(parseInt(parts[1], 10)) && !_underscore2.default.isNaN(parseInt(parts[2], 10))) {\n          var _year3 = parseInt(parts[0], 10);\n\n          var month = parseInt(parts[1], 10);\n          var day = parseInt(parts[2], 10);\n          t = _moment2.default.utc([_year3, month - 1, day]);\n\n          if (format) {\n            return t.format(format);\n          } else {\n            return t.format(\"MMMM Do YYYY\");\n          }\n        }\n\n        break;\n\n      case 2:\n        var rangeRegex = /([0-9]+)([smhd])/;\n        var sizeParts = rangeRegex.exec(parts[0]);\n\n        if (sizeParts && sizeParts.length >= 3 && !_underscore2.default.isNaN(parseInt(parts[1], 10))) {\n          return index;\n        } else if (!_underscore2.default.isNaN(parseInt(parts[0], 10)) && !_underscore2.default.isNaN(parseInt(parts[1], 10))) {\n          var _year4 = parseInt(parts[0], 10);\n\n          var _month2 = parseInt(parts[1], 10);\n\n          t = _moment2.default.utc([_year4, _month2 - 1]);\n\n          if (format) {\n            return t.format(format);\n          } else {\n            return t.format(\"MMMM\");\n          }\n        }\n\n        break;\n\n      case 1:\n        var year = parts[0];\n        t = _moment2.default.utc([year]);\n\n        if (format) {\n          return t.format(format);\n        } else {\n          return t.format(\"YYYY\");\n        }\n\n        break;\n    }\n\n    return index;\n  },\n  isMissing: function isMissing(val) {\n    return _underscore2.default.isNull(val) || _underscore2.default.isUndefined(val) || _underscore2.default.isNaN(val);\n  },\n\n  /**\n   * Split the field spec if it is not already a list.\n   *\n   * Also, allow for deep fields to be passed in as a tuple because\n   * it will need to be used as a dict key in some of the processor\n   * Options.\n   *\n   * This is deployed in Event.get() to process anything passed\n   * to it, but this should also be deployed \"upstream\" to avoid\n   * having that split() done over and over in a loop.\n   */\n  fieldPathToArray: function fieldPathToArray(fieldSpec) {\n    if (_underscore2.default.isArray(fieldSpec) || _underscore2.default.isFunction(fieldSpec)) {\n      return fieldSpec;\n    } else if (_underscore2.default.isString(fieldSpec)) {\n      return fieldSpec.split(\".\");\n    } else if (_underscore2.default.isUndefined(fieldSpec)) {\n      return [\"value\"];\n    }\n  },\n\n  /**\n   * Generate a list of all possible field paths in an object. This is\n   * for to determine all deep paths when none is given.\n   */\n  generatePaths: function generatePaths(newData) {\n    var _marked =\n    /*#__PURE__*/\n    _regenerator2.default.mark(recurse);\n\n    var paths = [];\n\n    function recurse(data) {\n      var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, path;\n\n      return _regenerator2.default.wrap(function recurse$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!_underscore2.default.isObject(data)) {\n                _context.next = 53;\n                break;\n              }\n\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 4;\n              _iterator = (0, _getIterator3.default)((0, _keys2.default)(data));\n\n            case 6:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 37;\n                break;\n              }\n\n              key = _step.value;\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 11;\n              _iterator2 = (0, _getIterator3.default)(recurse(data[key], [].concat((0, _toConsumableArray3.default)(keys), [key])));\n\n            case 13:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 20;\n                break;\n              }\n\n              path = _step2.value;\n              _context.next = 17;\n              return path;\n\n            case 17:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 13;\n              break;\n\n            case 20:\n              _context.next = 26;\n              break;\n\n            case 22:\n              _context.prev = 22;\n              _context.t0 = _context[\"catch\"](11);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t0;\n\n            case 26:\n              _context.prev = 26;\n              _context.prev = 27;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n\n            case 29:\n              _context.prev = 29;\n\n              if (!_didIteratorError2) {\n                _context.next = 32;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 32:\n              return _context.finish(29);\n\n            case 33:\n              return _context.finish(26);\n\n            case 34:\n              _iteratorNormalCompletion = true;\n              _context.next = 6;\n              break;\n\n            case 37:\n              _context.next = 43;\n              break;\n\n            case 39:\n              _context.prev = 39;\n              _context.t1 = _context[\"catch\"](4);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 43:\n              _context.prev = 43;\n              _context.prev = 44;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 46:\n              _context.prev = 46;\n\n              if (!_didIteratorError) {\n                _context.next = 49;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 49:\n              return _context.finish(46);\n\n            case 50:\n              return _context.finish(43);\n\n            case 51:\n              _context.next = 55;\n              break;\n\n            case 53:\n              _context.next = 55;\n              return keys;\n\n            case 55:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _marked, this, [[4, 39, 43, 51], [11, 22, 26, 34], [27,, 29, 33], [44,, 46, 50]]);\n    }\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = (0, _getIterator3.default)(recurse(newData)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var key = _step3.value;\n        paths.push(key);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    return paths;\n  },\n  //\n  // Functions to turn constructor args\n  // into other stuff\n  //\n  timestampFromArg: function timestampFromArg(arg) {\n    if (_underscore2.default.isNumber(arg)) {\n      return new Date(arg);\n    } else if (_underscore2.default.isString(arg)) {\n      return new Date(+arg);\n    } else if (_underscore2.default.isDate(arg)) {\n      return new Date(arg.getTime());\n    } else if (_moment2.default.isMoment(arg)) {\n      return new Date(arg.valueOf());\n    } else {\n      throw new Error(\"Unable to get timestamp from \" + arg + \". Should be a number, date, or moment.\");\n    }\n  },\n  timeRangeFromArg: function timeRangeFromArg(arg) {\n    if (arg instanceof _timerange2.default) {\n      return arg;\n    } else if (_underscore2.default.isString(arg)) {\n      var _arg$split = arg.split(\",\"),\n          _arg$split2 = (0, _slicedToArray3.default)(_arg$split, 2),\n          begin = _arg$split2[0],\n          end = _arg$split2[1];\n\n      return new _timerange2.default([+begin, +end]);\n    } else if (_underscore2.default.isArray(arg) && arg.length === 2) {\n      return new _timerange2.default(arg);\n    } else {\n      throw new Error(\"Unable to parse timerange. Should be a TimeRange. Got \" + arg + \".\");\n    }\n  },\n  indexFromArgs: function indexFromArgs(arg1) {\n    var arg2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (_underscore2.default.isString(arg1)) {\n      return new _index2.default(arg1, arg2);\n    } else if (arg1 instanceof _index2.default) {\n      return arg1;\n    } else {\n      throw new Error(\"Unable to get index from \" + arg1 + \". Should be a string or Index.\");\n    }\n  },\n  dataFromArg: function dataFromArg(arg) {\n    var data = void 0;\n\n    if (_underscore2.default.isObject(arg)) {\n      // Deeply convert the data to Immutable Map\n      data = new _immutable2.default.fromJS(arg);\n    } else if (data instanceof _immutable2.default.Map) {\n      // Copy reference to the data\n      data = arg;\n    } else if (_underscore2.default.isNumber(arg) || _underscore2.default.isString(arg)) {\n      // Just add it to the value key of a new Map\n      // e.g. new Event(t, 25); -> t, {value: 25}\n      data = new _immutable2.default.Map({\n        value: arg\n      });\n    } else {\n      throw new Error(\"Unable to interpret event data from \" + arg + \".\");\n    }\n\n    return data;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}