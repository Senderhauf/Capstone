{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _merge = require(\"merge\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _reactDom = require(\"react-dom\");\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _pondjs = require(\"pondjs\");\n\nvar _EventMarker = require(\"./EventMarker\");\n\nvar _EventMarker2 = _interopRequireDefault(_EventMarker);\n\nvar _util = require(\"../js/util\");\n\nvar _styler = require(\"../js/styler\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n *  Copyright (c) 2015-present, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n// eslint-disable-line\n\n\nvar defaultStyle = {\n  normal: {\n    fill: \"steelblue\",\n    opacity: 0.8\n  },\n  highlighted: {\n    fill: \"steelblue\",\n    opacity: 1.0\n  },\n  selected: {\n    fill: \"steelblue\",\n    opacity: 1.0\n  },\n  muted: {\n    fill: \"steelblue\",\n    opacity: 0.4\n  }\n};\n/**\n * The `<ScatterChart >` widget is able to display multiple columns of a series\n * scattered across a time axis.\n *\n * The ScatterChart should be used within `<ChartContainer>` etc.,\n * as this will construct the horizontal and vertical axis, and\n * manage other elements. As with other charts, this lets them be stacked or\n * overlaid on top of each other.\n *\n * A custom info overlay lets you hover over the data and examine points. Points\n * can be selected or highlighted.\n *\n * ```\n * <ChartContainer timeRange={series.timerange()}>\n *     <ChartRow height=\"150\">\n *         <YAxis id=\"wind\" label=\"Wind gust (mph)\" labelOffset={-5}\n *                min={0} max={series.max()} width=\"100\" type=\"linear\" format=\",.1f\"/>\n *         <Charts>\n *             <ScatterChart\n *               axis=\"wind\"\n *               series={series}\n *               style={{color: \"steelblue\", opacity: 0.5}} />\n *         </Charts>\n *     </ChartRow>\n * </ChartContainer>\n * ```\n *\n * ### Styling\n *\n * A scatter chart supports per-column or per-event styling. Styles can be set for\n * each of the four states that are possible for each event: normal, highlighted,\n * selected or muted. To style per-column, supply an object. For per-event styling\n * supply a function: `(event, column) => {}` The functon will return a style object.\n * See the `style` prop in the API documentation for more information.\n *\n * Separately the size of the dots can be controlled with the `radius` prop. This\n * can either be a fixed value (e.g. 2.0), or a function. If a function is supplied\n * it will be called as `(event, column) => {}` and should return the size.\n *\n * The hover info for each point is also able to be styled using the info style.\n * This enables you to control the drawing of the box and connecting lines. Using\n * the `infoWidth` and `infoHeight` props you can control the size of the box, which\n * is fixed.\n */\n\nvar ScatterChart = function (_React$Component) {\n  _inherits(ScatterChart, _React$Component);\n\n  function ScatterChart(props) {\n    _classCallCheck(this, ScatterChart);\n\n    var _this = _possibleConstructorReturn(this, (ScatterChart.__proto__ || Object.getPrototypeOf(ScatterChart)).call(this, props));\n\n    _this.handleHover = _this.handleHover.bind(_this);\n    _this.handleHoverLeave = _this.handleHoverLeave.bind(_this);\n    return _this;\n  } // get the event mouse position relative to the event rect\n\n\n  _createClass(ScatterChart, [{\n    key: \"getOffsetMousePosition\",\n    value: function getOffsetMousePosition(e) {\n      var offset = (0, _util.getElementOffset)(this.eventrect);\n      var x = e.pageX - offset.left;\n      var y = e.pageY - offset.top;\n      return [Math.round(x), Math.round(y)];\n    } //\n    // Event handlers\n    //\n\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e, event, column) {\n      var point = {\n        event: event,\n        column: column\n      };\n\n      if (this.props.onSelectionChange) {\n        this.props.onSelectionChange(point);\n      }\n    }\n  }, {\n    key: \"handleHover\",\n    value: function handleHover(e) {\n      var _getOffsetMousePositi = this.getOffsetMousePosition(e),\n          _getOffsetMousePositi2 = _slicedToArray(_getOffsetMousePositi, 2),\n          x = _getOffsetMousePositi2[0],\n          y = _getOffsetMousePositi2[1];\n\n      var point = void 0;\n      var minDistance = Infinity;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.props.columns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var column = _step.value;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = this.props.series.events()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var event = _step2.value;\n              var t = event.timestamp();\n              var value = event.get(column);\n              var px = this.props.timeScale(t);\n              var py = this.props.yScale(value);\n              var distance = Math.sqrt((px - x) * (px - x) + (py - y) * (py - y));\n\n              if (distance < minDistance) {\n                point = {\n                  event: event,\n                  column: column\n                };\n                minDistance = distance;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (this.props.onMouseNear) {\n        this.props.onMouseNear(point);\n      }\n    }\n  }, {\n    key: \"handleHoverLeave\",\n    value: function handleHoverLeave() {\n      if (this.props.onMouseNear) {\n        this.props.onMouseNear(null);\n      }\n    } //\n    // Internal methods\n    //\n\n  }, {\n    key: \"providedStyleMap\",\n    value: function providedStyleMap(column, event) {\n      var style = {};\n\n      if (this.props.style) {\n        if (this.props.style instanceof _styler.Styler) {\n          style = this.props.style.scatterChartStyle()[column];\n        } else if (_underscore2.default.isFunction(this.props.style)) {\n          style = this.props.style(column, event);\n        } else if (_underscore2.default.isObject(this.props.style)) {\n          style = this.props.style ? this.props.style[column] : defaultStyle;\n        }\n      }\n\n      return style;\n    }\n    /**\n     * Returns the style used for drawing the path\n     */\n\n  }, {\n    key: \"style\",\n    value: function style(column, event) {\n      var style = void 0;\n      var styleMap = this.providedStyleMap(column, event);\n\n      var isHighlighted = this.props.highlight && column === this.props.highlight.column && _pondjs.Event.is(this.props.highlight.event, event);\n\n      var isSelected = this.props.selected && column === this.props.selected.column && _pondjs.Event.is(this.props.selected.event, event);\n\n      if (this.props.selected) {\n        if (isSelected) {\n          style = (0, _merge2.default)(true, defaultStyle.selected, styleMap.selected ? styleMap.selected : {});\n        } else if (isHighlighted) {\n          style = (0, _merge2.default)(true, defaultStyle.highlighted, styleMap.highlighted ? styleMap.highlighted : {});\n        } else {\n          style = (0, _merge2.default)(true, defaultStyle.muted, styleMap.muted ? styleMap.muted : {});\n        }\n      } else if (isHighlighted) {\n        style = (0, _merge2.default)(true, defaultStyle.highlighted, styleMap.highlighted ? styleMap.highlighted : {});\n      } else {\n        style = (0, _merge2.default)(true, defaultStyle.normal, styleMap.normal ? styleMap.normal : {});\n      }\n\n      return style;\n    } //\n    // Render\n    //\n\n  }, {\n    key: \"renderScatter\",\n    value: function renderScatter() {\n      var _this2 = this;\n\n      var _props = this.props,\n          series = _props.series,\n          timeScale = _props.timeScale,\n          yScale = _props.yScale;\n      var points = [];\n      var hoverOverlay = void 0; // if selectionChange is enabled, pointerEvents should be enabled as well\n\n      var pointerEvents = this.props.onSelectionChange ? \"auto\" : \"none\";\n      this.props.columns.forEach(function (column) {\n        var key = 1;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          var _loop = function _loop() {\n            var event = _step3.value;\n            var t = new Date(event.begin().getTime() + (event.end().getTime() - event.begin().getTime()) / 2);\n            var value = event.get(column);\n\n            var badPoint = _underscore2.default.isNull(value) || _underscore2.default.isNaN(value) || _underscore2.default.isUndefined(value);\n\n            var style = _this2.style(column, event);\n\n            if (!badPoint) {\n              var x = timeScale(t);\n              var y = yScale(value);\n              var radius = _underscore2.default.isFunction(_this2.props.radius) ? _this2.props.radius(event, column) : +_this2.props.radius;\n\n              var isHighlighted = _this2.props.highlight && _pondjs.Event.is(_this2.props.highlight.event, event) && column === _this2.props.highlight.column; // Hover info. Note that we just pass all of our props down\n              // into the EventMarker here, but the interesting ones are:\n              // * the info values themselves\n              // * the infoStyle\n              // * infoWidth and infoHeight\n\n\n              if (isHighlighted && _this2.props.info) {\n                hoverOverlay = _react2.default.createElement(_EventMarker2.default, _extends({}, _this2.props, {\n                  event: event,\n                  column: column,\n                  marker: \"circle\",\n                  markerRadius: 0\n                }));\n              }\n\n              points.push(_react2.default.createElement(\"circle\", {\n                key: column + \"-\" + key,\n                cx: x,\n                cy: y,\n                r: radius,\n                style: style,\n                pointerEvents: pointerEvents,\n                onMouseMove: _this2.handleHover,\n                onClick: function onClick(e) {\n                  return _this2.handleClick(e, event, column);\n                }\n              }));\n              key += 1;\n            }\n          };\n\n          for (var _iterator3 = series.events()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            _loop();\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      });\n      return _react2.default.createElement(\"g\", null, points, hoverOverlay);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      return _react2.default.createElement(\"g\", null, _react2.default.createElement(\"rect\", {\n        key: \"scatter-hit-rect\",\n        ref: function ref(c) {\n          _this3.eventrect = c;\n        },\n        style: {\n          opacity: 0.0\n        },\n        x: 0,\n        y: 0,\n        width: this.props.width,\n        height: this.props.height,\n        onMouseMove: this.handleHover,\n        onMouseLeave: this.handleHoverLeave\n      }), this.renderScatter());\n    }\n  }]);\n\n  return ScatterChart;\n}(_react2.default.Component);\n\nexports.default = ScatterChart;\nScatterChart.propTypes = {\n  /**\n   * Show or hide this chart\n   */\n  visible: _propTypes2.default.bool,\n\n  /**\n   * What [Pond TimeSeries](https://esnet-pondjs.appspot.com/#/timeseries) data to visualize\n   */\n  series: _propTypes2.default.instanceOf(_pondjs.TimeSeries).isRequired,\n\n  /**\n   * Which columns of the series to render\n   *\n   * NOTE : Columns can't have periods because periods\n   * represent a path to deep data in the underlying events\n   * (i.e. reference into nested data structures)\n   */\n  columns: _propTypes2.default.arrayOf(_propTypes2.default.string),\n\n  /**\n   * Reference to the axis which provides the vertical scale for drawing. e.g.\n   * specifying axis=\"trafficRate\" would refer the y-scale to the YAxis of id=\"trafficRate\".\n   */\n  axis: _propTypes2.default.string.isRequired,\n  // eslint-disable-line\n\n  /**\n   * The radius of the points in the scatter chart.\n   *\n   * If this is a number it will be used as the radius for every point.\n   * If this is a function it will be called for each event.\n   *\n   * The function is called with the event and the column name and must return a number.\n   *\n   * For example this function will use the radius column of the event:\n   *\n   * ```\n   * const radius = (event, column) => {\n   *    return event.get(\"radius\");\n   * }\n   * ```\n   */\n  radius: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func, _propTypes2.default.instanceOf(_styler.Styler)]),\n\n  /**\n   * The style of the scatter chart drawing (using SVG CSS properties).\n   * This is an object with a key for each column which is being plotted,\n   * per the `columns` prop. Each of those keys has an object as its\n   * value which has keys which are style properties for an SVG <Circle> and\n   * the value to use.\n   *\n   * For example:\n   * ```\n   * style = {\n   *     columnName: {\n   *         normal: {\n   *             fill: \"steelblue\",\n   *             opacity: 0.8,\n   *         },\n   *         highlighted: {\n   *             fill: \"#a7c4dd\",\n   *             opacity: 1.0,\n   *         },\n   *         selected: {\n   *             fill: \"orange\",\n   *             opacity: 1.0,\n   *         },\n   *         muted: {\n   *             fill: \"grey\",\n   *             opacity: 0.5\n   *         }\n   *     }\n   * }\n   * ```\n   *\n   * You can also supply a function, which will be called with an event\n   * and column. The function should return an object containing the\n   * 4 states (normal, highlighted, selected and muted) and the corresponding\n   * CSS properties.\n   */\n  style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),\n\n  /**\n   * The style of the info box and connecting lines. The style should\n   * be an object of the form { line, box }. Line and box are both objects\n   * containing the inline CSS for those elements of the info tracker.\n   */\n  infoStyle: _propTypes2.default.shape({\n    line: _propTypes2.default.object,\n    // eslint-disable-line\n    box: _propTypes2.default.object // eslint-disable-line\n\n  }),\n\n  /**\n   * The width of the hover info box\n   */\n  infoWidth: _propTypes2.default.number,\n  // eslint-disable-line\n\n  /**\n   * The height of the hover info box\n   */\n  infoHeight: _propTypes2.default.number,\n  // eslint-disable-line\n\n  /**\n   * The values to show in the info box. This is an array of\n   * objects, with each object specifying the label and value\n   * to be shown in the info box.\n   */\n  info: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    label: _propTypes2.default.string,\n    // eslint-disable-line\n    value: _propTypes2.default.string // eslint-disable-line\n\n  })),\n\n  /**\n   * The selected dot, which will be rendered in the \"selected\" style.\n   * If a dot is selected, all other dots will be rendered in the \"muted\" style.\n   *\n   * See also `onSelectionChange`\n   */\n  selected: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    event: _propTypes2.default.instanceOf(_pondjs.Event),\n    column: _propTypes2.default.string\n  })),\n\n  /**\n   * A callback that will be called when the selection changes. It will be called\n   * with an object containing the event and column.\n   */\n  onSelectionChange: _propTypes2.default.func,\n\n  /**\n   * The highlighted dot, as an object containing the { event, column },\n   * which will be rendered in the \"highlighted\" style.\n   *\n   * See also the prop `onMouseNear`.\n   */\n  highlight: _propTypes2.default.shape({\n    event: _propTypes2.default.instanceOf(_pondjs.Event),\n    column: _propTypes2.default.string\n  }),\n\n  /**\n   * Will be called with the nearest point to the cursor. The callback\n   * will contain the point, which is a map of { event, column }.\n   */\n  onMouseNear: _propTypes2.default.func,\n\n  /**\n   * [Internal] The timeScale supplied by the surrounding ChartContainer\n   */\n  timeScale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The yScale supplied by the associated YAxis\n   */\n  yScale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The width supplied by the surrounding ChartContainer\n   */\n  width: _propTypes2.default.number,\n\n  /**\n   * [Internal] The height supplied by the surrounding ChartContainer\n   */\n  height: _propTypes2.default.number\n};\nScatterChart.defaultProps = {\n  visible: true,\n  columns: [\"value\"],\n  radius: 2.0,\n  infoStyle: {\n    stroke: \"#999\",\n    fill: \"white\",\n    opacity: 0.9,\n    pointerEvents: \"none\"\n  },\n  stemStyle: {\n    stroke: \"#999\",\n    cursor: \"crosshair\",\n    pointerEvents: \"none\"\n  },\n  markerStyle: {\n    fill: \"#999\"\n  },\n  infoWidth: 90,\n  infoHeight: 30\n};","map":null,"metadata":{},"sourceType":"script"}