{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _toConsumableArray2 = require(\"babel-runtime/helpers/toConsumableArray\");\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _toArray2 = require(\"babel-runtime/helpers/toArray\");\n\nvar _toArray3 = _interopRequireDefault(_toArray2);\n\nvar _objectWithoutProperties2 = require(\"babel-runtime/helpers/objectWithoutProperties\");\n\nvar _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _immutable = require(\"immutable\");\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nvar _collection = require(\"./collection\");\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _event = require(\"./event\");\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _timeevent = require(\"./timeevent\");\n\nvar _timeevent2 = _interopRequireDefault(_timeevent);\n\nvar _timerangeevent = require(\"./timerangeevent\");\n\nvar _timerangeevent2 = _interopRequireDefault(_timerangeevent);\n\nvar _indexedevent = require(\"./indexedevent\");\n\nvar _indexedevent2 = _interopRequireDefault(_indexedevent);\n\nvar _pipeline = require(\"./pipeline.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction buildMetaData(meta) {\n  var d = meta ? meta : {}; // Name\n\n  d.name = meta.name ? meta.name : \"\"; // Index\n\n  if (meta.index) {\n    if (_underscore2.default.isString(meta.index)) {\n      d.index = new _index2.default(meta.index);\n    } else if (meta.index instanceof _index2.default) {\n      d.index = meta.index;\n    }\n  } // UTC or Local time\n\n\n  d.utc = true;\n\n  if (_underscore2.default.isBoolean(meta.utc)) {\n    d.utc = meta.utc;\n  }\n\n  return new _immutable2.default.Map(d);\n}\n/**\n * A `TimeSeries` represents a series of events, with each event being a combination of:\n *\n *  - time (or `TimeRange`, or `Index`)\n *  - data - corresponding set of key/values.\n *\n * ### Construction\n *\n * Currently you can initialize a `TimeSeries` with either a list of events, or with a data format that looks like this:\n *\n * ```javascript\n * const data = {\n *     name: \"trafficc\",\n *     columns: [\"time\", \"value\"],\n *     points: [\n *         [1400425947000, 52],\n *         [1400425948000, 18],\n *         [1400425949000, 26],\n *         [1400425950000, 93],\n *         ...\n *     ]\n * };\n * ```\n *\n * To create a new TimeSeries object from the above format, simply use the constructor:\n *\n * ```javascript\n * const series = new TimeSeries(data);\n * ```\n *\n * The format of the data is as follows:\n *\n *  - **name** - optional, but a good practice\n *  - **columns** - are necessary and give labels to the data in the points.\n *  - **points** - are an array of tuples. Each row is at a different time (or timerange), and each value corresponds to the column labels.\n *\n * As just hinted at, the first column may actually be:\n *\n *  - \"time\"\n *  - \"timeRange\" represented by a `TimeRange`\n *  - \"index\" - a time range represented by an `Index`. By using an index it is possible, for example, to refer to a specific month:\n *\n * ```javascript\n * const availabilityData = {\n *     name: \"Last 3 months availability\",\n *     columns: [\"index\", \"uptime\"],\n *     points: [\n *         [\"2015-06\", \"100%\"], // <-- 2015-06 specified here represents June 2015\n *         [\"2015-05\", \"92%\"],\n *         [\"2015-04\", \"87%\"],\n *     ]\n * };\n * ```\n *\n * Alternatively, you can construct a `TimeSeries` with a list of events.\n * These may be `TimeEvents`, `TimeRangeEvents` or `IndexedEvents`. Here's an example of that:\n *\n * ```javascript\n * const events = [];\n * events.push(new TimeEvent(new Date(2015, 7, 1), {value: 27}));\n * events.push(new TimeEvent(new Date(2015, 8, 1), {value: 29}));\n * const series = new TimeSeries({\n *     name: \"avg temps\",\n *     events: events\n * });\n * ```\n *\n * ### Nested data\n *\n * The values do not have to be simple types like the above examples. Here's an\n * example where each value is itself an object with \"in\" and \"out\" keys:\n *\n * ```javascript\n * const series = new TimeSeries({\n *     name: \"Map Traffic\",\n *     columns: [\"time\", \"NASA_north\", \"NASA_south\"],\n *     points: [\n *         [1400425951000, {in: 100, out: 200}, {in: 145, out: 135}],\n *         [1400425952000, {in: 200, out: 400}, {in: 146, out: 142}],\n *         [1400425953000, {in: 300, out: 600}, {in: 147, out: 158}],\n *         [1400425954000, {in: 400, out: 800}, {in: 155, out: 175}],\n *     ]\n * });\n * ```\n *\n * Complex data is stored in an Immutable structure. To get a value out of nested\n * data like this you will get the event you want (by row), as usual, and then use\n * `get()` to fetch the value by column name. The result of this call will be a\n * JSON copy of the Immutable data so you can query deeper in the usual way:\n *\n * ```javascript\n * series.at(0).get(\"NASA_north\")[\"in\"]  // 200`\n * ```\n *\n * It is then possible to use a value mapper function when calculating different\n * properties. For example, to get the average \"in\" value of the NASA_north column:\n *\n * ```javascript\n * series.avg(\"NASA_north\", d => d.in);  // 250\n * ```\n */\n\n/*\n *  Copyright (c) 2015-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar TimeSeries = function () {\n  function TimeSeries(arg) {\n    (0, _classCallCheck3.default)(this, TimeSeries);\n    this._collection = null; // Collection\n\n    this._data = null; // Meta data\n\n    if (arg instanceof TimeSeries) {\n      //\n      // Copy another TimeSeries\n      //\n      var other = arg;\n      this._data = other._data;\n      this._collection = other._collection;\n    } else if (_underscore2.default.isObject(arg)) {\n      //\n      // TimeSeries(object data) where data may be:\n      //    { \"events\": [event-1, event-2, ..., event-n]}\n      // or\n      //    { \"columns\": [time|timerange|index, column-1, ..., column-n]\n      //      \"points\": [\n      //         [t1, v1, v2, ..., v2],\n      //         [t2, v1, v2, ..., vn],\n      //         ...\n      //      ]\n      //    }\n      var obj = arg;\n\n      if (_underscore2.default.has(obj, \"events\")) {\n        //\n        // Initialized from an event list\n        //\n        var events = obj.events,\n            meta1 = (0, _objectWithoutProperties3.default)(obj, [\"events\"]); //eslint-disable-line\n\n        this._collection = new _collection2.default(events);\n        this._data = buildMetaData(meta1);\n      } else if (_underscore2.default.has(obj, \"collection\")) {\n        //\n        // Initialized from a Collection\n        //\n        var collection = obj.collection,\n            meta3 = (0, _objectWithoutProperties3.default)(obj, [\"collection\"]); //eslint-disable-line\n\n        this._collection = collection;\n        this._data = buildMetaData(meta3);\n      } else if (_underscore2.default.has(obj, \"columns\") && _underscore2.default.has(obj, \"points\")) {\n        //\n        // Initialized from the wire format\n        //\n        var columns = obj.columns,\n            points = obj.points,\n            _obj$utc = obj.utc,\n            utc = _obj$utc === undefined ? true : _obj$utc,\n            meta2 = (0, _objectWithoutProperties3.default)(obj, [\"columns\", \"points\", \"utc\"]); //eslint-disable-line\n\n        var _columns = (0, _toArray3.default)(columns),\n            eventKey = _columns[0],\n            eventFields = _columns.slice(1);\n\n        var _events = points.map(function (point) {\n          var _point = (0, _toArray3.default)(point),\n              t = _point[0],\n              eventValues = _point.slice(1);\n\n          var d = _underscore2.default.object(eventFields, eventValues);\n\n          var options = utc;\n\n          switch (eventKey) {\n            case \"time\":\n              return new _timeevent2.default(t, d, options);\n\n            case \"index\":\n              return new _indexedevent2.default(t, d, options);\n\n            case \"timerange\":\n              return new _timerangeevent2.default(t, d, options);\n\n            default:\n              throw new Error(\"Unknown event type\");\n          }\n        });\n\n        this._collection = new _collection2.default(_events);\n        this._data = buildMetaData(meta2);\n      }\n\n      if (!this._collection.isChronological()) {\n        throw new Error(\"TimeSeries was passed non-chronological events\");\n      }\n    }\n  } //\n  // Serialize\n  //\n\n  /**\n   * Turn the TimeSeries into regular javascript objects\n   */\n\n\n  (0, _createClass3.default)(TimeSeries, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      var e = this.atFirst();\n\n      if (!e) {\n        return;\n      }\n\n      var columnList = this.columns();\n      var columns = void 0;\n\n      if (e instanceof _timeevent2.default) {\n        columns = [\"time\"].concat((0, _toConsumableArray3.default)(columnList));\n      } else if (e instanceof _timerangeevent2.default) {\n        columns = [\"timerange\"].concat((0, _toConsumableArray3.default)(columnList));\n      } else if (e instanceof _indexedevent2.default) {\n        columns = [\"index\"].concat((0, _toConsumableArray3.default)(columnList));\n      }\n\n      var points = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)(this._collection.events()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _e = _step.value;\n          points.push(_e.toPoint(columnList));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return _underscore2.default.extend(this._data.toJSON(), {\n        columns: columns,\n        points: points\n      });\n    }\n    /**\n     * Represent the TimeSeries as a string\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return (0, _stringify2.default)(this.toJSON());\n    }\n    /**\n     * Returns the extents of the TimeSeries as a TimeRange.\n     */\n\n  }, {\n    key: \"timerange\",\n    value: function timerange() {\n      return this._collection.range();\n    }\n    /**\n     * Alias for `timerange()`\n     */\n\n  }, {\n    key: \"range\",\n    value: function range() {\n      return this.timerange();\n    }\n    /**\n     * Gets the earliest time represented in the TimeSeries.\n     *\n     * @return {Date} Begin time\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      return this.range().begin();\n    }\n    /**\n     * Gets the latest time represented in the TimeSeries.\n     *\n     * @return {Date} End time\n     */\n\n  }, {\n    key: \"end\",\n    value: function end() {\n      return this.range().end();\n    }\n    /**\n     * Access a specific TimeSeries event via its position\n     *\n     * @param {number} pos The event position\n     */\n\n  }, {\n    key: \"at\",\n    value: function at(pos) {\n      return this._collection.at(pos);\n    }\n    /**\n     * Returns an event in the series by its time. This is the same\n     * as calling `bisect` first and then using `at` with the index.\n     *\n     * @param  {Date} time The time of the event.\n     * @return {TimeEvent|IndexedEvent|TimeRangeEvent}\n     */\n\n  }, {\n    key: \"atTime\",\n    value: function atTime(time) {\n      var pos = this.bisect(time);\n\n      if (pos >= 0 && pos < this.size()) {\n        return this.at(pos);\n      }\n    }\n    /**\n     * Returns the first event in the series.\n     *\n     * @return {TimeEvent|IndexedEvent|TimeRangeEvent}\n     */\n\n  }, {\n    key: \"atFirst\",\n    value: function atFirst() {\n      return this._collection.atFirst();\n    }\n    /**\n     * Returns the last event in the series.\n     *\n     * @return {TimeEvent|IndexedEvent|TimeRangeEvent}\n     */\n\n  }, {\n    key: \"atLast\",\n    value: function atLast() {\n      return this._collection.atLast();\n    }\n    /**\n     * Generator to return all the events in the series\n     *\n     * @example\n     * ```\n     * for (let event of series.events()) {\n     *     console.log(event.toString());\n     * }\n     * ```\n     */\n\n  }, {\n    key: \"events\",\n    value:\n    /*#__PURE__*/\n    _regenerator2.default.mark(function events() {\n      var i;\n      return _regenerator2.default.wrap(function events$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              i = 0;\n\n            case 1:\n              if (!(i < this.size())) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 4;\n              return this.at(i);\n\n            case 4:\n              i++;\n              _context.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, events, this);\n    })\n    /**\n     * Sets a new underlying collection for this TimeSeries.\n     *\n     * @param {Collection}  collection       The new collection\n     * @param {boolean}     isChronological  Causes the chronological\n     *                                       order of the events to\n     *                                       not be checked\n     *\n     * @return {TimeSeries}                  A new TimeSeries\n     */\n\n  }, {\n    key: \"setCollection\",\n    value: function setCollection(collection) {\n      var isChronological = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!isChronological && !collection.isChronological()) {\n        throw new Error(\"Collection supplied is not chronological\");\n      }\n\n      var result = new TimeSeries(this);\n\n      if (collection) {\n        result._collection = collection;\n      } else {\n        result._collection = new _collection2.default();\n      }\n\n      return result;\n    }\n    /**\n     * Returns the index that bisects the TimeSeries at the time specified.\n     *\n     * @param  {Date}    t   The time to bisect the TimeSeries with\n     * @param  {number}  b   The position to begin searching at\n     *\n     * @return {number}      The row number that is the greatest, but still below t.\n     */\n\n  }, {\n    key: \"bisect\",\n    value: function bisect(t, b) {\n      var tms = t.getTime();\n      var size = this.size();\n      var i = b || 0;\n\n      if (!size) {\n        return undefined;\n      }\n\n      for (; i < size; i++) {\n        var ts = this.at(i).timestamp().getTime();\n\n        if (ts > tms) {\n          return i - 1 >= 0 ? i - 1 : 0;\n        } else if (ts === tms) {\n          return i;\n        }\n      }\n\n      return i - 1;\n    }\n    /**\n     * Perform a slice of events within the TimeSeries, returns a new\n     * TimeSeries representing a portion of this TimeSeries from\n     * begin up to but not including end.\n     *\n     * @param {Number} begin   The position to begin slicing\n     * @param {Number} end     The position to end slicing\n     *\n     * @return {TimeSeries}    The new, sliced, TimeSeries.\n     */\n\n  }, {\n    key: \"slice\",\n    value: function slice(begin, end) {\n      var sliced = this._collection.slice(begin, end);\n\n      return this.setCollection(sliced, true);\n    }\n    /**\n     * Crop the TimeSeries to the specified TimeRange and\n     * return a new TimeSeries.\n     *\n     * @param {TimeRange} timerange   The bounds of the new TimeSeries\n     *\n     * @return {TimeSeries}    The new, cropped, TimeSeries.\n     */\n\n  }, {\n    key: \"crop\",\n    value: function crop(timerange) {\n      var timerangeBegin = timerange.begin();\n      var beginPos = this.bisect(timerangeBegin);\n      var bisectedEventOutsideRange = this.at(beginPos).timestamp() < timerangeBegin;\n      beginPos = bisectedEventOutsideRange ? beginPos + 1 : beginPos;\n      var endPos = this.bisect(timerange.end(), beginPos);\n      return this.slice(beginPos, endPos + 1);\n    }\n    /**\n     * Returns a new TimeSeries by testing the fieldPath\n     * values for being valid (not NaN, null or undefined).\n     *\n     * The resulting TimeSeries will be clean (for that fieldPath).\n     *\n     * @param  {string}      fieldPath  Name of value to look up. If not supplied,\n     *                                  defaults to ['value']. \"Deep\" syntax is\n     *                                  ['deep', 'value'] or 'deep.value'\n     *\n     * @return {TimeSeries}             A new, modified, TimeSeries.\n     */\n\n  }, {\n    key: \"clean\",\n    value: function clean(fieldSpec) {\n      var cleaned = this._collection.clean(fieldSpec);\n\n      return this.setCollection(cleaned, true);\n    }\n    /**\n     * Generator to return all the events in the collection.\n     *\n     * @example\n     * ```\n     * for (let event of timeseries.events()) {\n     *     console.log(event.toString());\n     * }\n     * ```\n     */\n\n  }, {\n    key: \"events\",\n    value:\n    /*#__PURE__*/\n    _regenerator2.default.mark(function events() {\n      var i;\n      return _regenerator2.default.wrap(function events$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              i = 0;\n\n            case 1:\n              if (!(i < this.size())) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 4;\n              return this.at(i);\n\n            case 4:\n              i++;\n              _context2.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, events, this);\n    }) //\n    // Access meta data about the series\n    //\n\n    /**\n     * Fetch the timeseries name\n     *\n     * @return {string} The name given to this TimeSeries\n     */\n\n  }, {\n    key: \"name\",\n    value: function name() {\n      return this._data.get(\"name\");\n    }\n    /**\n     * Rename the timeseries\n     */\n\n  }, {\n    key: \"setName\",\n    value: function setName(name) {\n      return this.setMeta(\"name\", name);\n    }\n    /**\n     * Fetch the timeseries Index, if it has one.\n     *\n     * @return {Index} The Index given to this TimeSeries\n     */\n\n  }, {\n    key: \"index\",\n    value: function index() {\n      return this._data.get(\"index\");\n    }\n    /**\n     * Fetch the timeseries Index, as a string, if it has one.\n     *\n     * @return {string} The Index, as a string, given to this TimeSeries\n     */\n\n  }, {\n    key: \"indexAsString\",\n    value: function indexAsString() {\n      return this.index() ? this.index().asString() : undefined;\n    }\n    /**\n     * Fetch the timeseries `Index`, as a `TimeRange`, if it has one.\n     *\n     * @return {TimeRange} The `Index`, as a `TimeRange`, given to this `TimeSeries`\n     */\n\n  }, {\n    key: \"indexAsRange\",\n    value: function indexAsRange() {\n      return this.index() ? this.index().asTimerange() : undefined;\n    }\n    /**\n     * Fetch the UTC flag, i.e. are the events in this `TimeSeries` in\n     * UTC or local time (if they are `IndexedEvent`s an event might be\n     * \"2014-08-31\". The actual time range of that representation\n     * depends on where you are. Pond supports thinking about that in\n     * either as a UTC day, or a local day).\n     *\n     * @return {TimeRange} The Index, as a TimeRange, given to this TimeSeries\n     */\n\n  }, {\n    key: \"isUTC\",\n    value: function isUTC() {\n      return this._data.get(\"utc\");\n    }\n    /**\n     * Fetch the list of column names. This is determined by\n     * traversing though the events and collecting the set.\n     *\n     * Note: the order is not defined\n     *\n     * @return {array} List of columns\n     */\n\n  }, {\n    key: \"columns\",\n    value: function columns() {\n      var c = {};\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = (0, _getIterator3.default)(this._collection.events()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var e = _step2.value;\n          var d = e.toJSON().data;\n\n          _underscore2.default.each(d, function (val, key) {\n            c[key] = true;\n          });\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return _underscore2.default.keys(c);\n    }\n    /**\n     * Returns the internal `Collection` of events for this `TimeSeries`\n     *\n     * @return {Collection} The collection backing this `TimeSeries`\n     */\n\n  }, {\n    key: \"collection\",\n    value: function collection() {\n      return this._collection;\n    }\n    /**\n     * Returns the meta data about this TimeSeries as a JSON object.\n     * Any extra data supplied to the TimeSeries constructor will be\n     * placed in the meta data object. This returns either all of that\n     * data as a JSON object, or a specific key if `key` is supplied.\n     *\n     * @param {string}   key   Optional specific part of the meta data\n     * @return {object}        The meta data\n     */\n\n  }, {\n    key: \"meta\",\n    value: function meta(key) {\n      if (!key) {\n        return this._data.toJSON();\n      } else {\n        return this._data.get(key);\n      }\n    }\n    /**\n     * Set new meta data for the TimeSeries. The result will\n     * be a new TimeSeries.\n     */\n\n  }, {\n    key: \"setMeta\",\n    value: function setMeta(key, value) {\n      var newTimeSeries = new TimeSeries(this);\n      var d = newTimeSeries._data;\n      var dd = d.set(key, value);\n      newTimeSeries._data = dd;\n      return newTimeSeries;\n    } //\n    // Access the series itself\n    //\n\n    /**\n     * Returns the number of events in this TimeSeries\n     *\n     * @return {number} Count of events\n     */\n\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this._collection ? this._collection.size() : 0;\n    }\n    /**\n     * Returns the number of valid items in this TimeSeries.\n     *\n     * Uses the fieldSpec to look up values in all events.\n     * It then counts the number that are considered valid, which\n     * specifically are not NaN, undefined or null.\n     *\n     * @return {number} Count of valid events\n     */\n\n  }, {\n    key: \"sizeValid\",\n    value: function sizeValid(fieldSpec) {\n      return this._collection.sizeValid(fieldSpec);\n    }\n    /**\n     * Returns the number of events in this TimeSeries. Alias\n     * for size().\n     *\n     * @return {number} Count of events\n     */\n\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this.size();\n    }\n    /**\n     * Returns the sum for the fieldspec\n     *\n     * @param {string} fieldPath  Column to find the stdev of. A deep value can\n     *                            be referenced with a string.like.this.  If not supplied\n     *                            the `value` column will be aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The sum\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum(fieldPath, filter) {\n      return this._collection.sum(fieldPath, filter);\n    }\n    /**\n     * Aggregates the events down to their maximum value\n     *\n     * @param {string} fieldPath  Column to find the max of. A deep value can\n     *                            be referenced with a string.like.this.  If not supplied\n     *                            the `value` column will be aggregated.\n     *\n     * @return {number}           The max value for the field\n     */\n\n  }, {\n    key: \"max\",\n    value: function max(fieldPath, filter) {\n      return this._collection.max(fieldPath, filter);\n    }\n    /**\n     * Aggregates the events down to their minimum value\n     *\n     * @param {string} fieldPath  Column to find the min of. A deep value can\n     *                            be referenced with a string.like.this.  If not supplied\n     *                            the `value` column will be aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The min value for the field\n     */\n\n  }, {\n    key: \"min\",\n    value: function min(fieldPath, filter) {\n      return this._collection.min(fieldPath, filter);\n    }\n    /**\n     * Aggregates the events in the TimeSeries down to their average\n     *\n     * @param {string} fieldPath  Column to find the avg of. A deep value can\n     *                            be referenced with a string.like.this.  If not supplied\n     *                            the `value` column will be aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The average\n     */\n\n  }, {\n    key: \"avg\",\n    value: function avg(fieldPath, filter) {\n      return this._collection.avg(fieldPath, filter);\n    }\n    /**\n     * Aggregates the events in the TimeSeries down to their mean (same as avg)\n     *\n     * @param {string} fieldPath  Column to find the mean of. A deep value can\n     *                            be referenced with a string.like.this.  If not supplied\n     *                            the `value` column will be aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The mean\n     */\n\n  }, {\n    key: \"mean\",\n    value: function mean(fieldPath, filter) {\n      return this._collection.mean(fieldPath, filter);\n    }\n    /**\n     * Aggregates the events down to their medium value\n     *\n     * @param {string} fieldPath  Column to find the median of. A deep value can\n     *                            be referenced with a string.like.this.  If not supplied\n     *                            the `value` column will be aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The resulting median value\n     */\n\n  }, {\n    key: \"median\",\n    value: function median(fieldPath, filter) {\n      return this._collection.median(fieldPath, filter);\n    }\n    /**\n     * Aggregates the events down to their stdev\n     *\n     * @param {string} fieldPath  Column to find the stdev of. A deep value can\n     *                            be referenced with a string.like.this.  If not supplied\n     *                            the `value` column will be aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The resulting stdev value\n     */\n\n  }, {\n    key: \"stdev\",\n    value: function stdev(fieldPath, filter) {\n      return this._collection.stdev(fieldPath, filter);\n    }\n    /**\n     * Gets percentile q within the TimeSeries. This works the same way as numpy.\n     *\n     * @param  {integer} q         The percentile (should be between 0 and 100)\n     *\n     * @param {string} fieldPath   Column to find the qth percentile of. A deep value can\n     *                             be referenced with a string.like.this.  If not supplied\n     *                             the `value` column will be aggregated.\n     *\n     * @param  {string}  interp    Specifies the interpolation method\n     *                             to use when the desired quantile lies between\n     *                             two data points. Options are: \"linear\", \"lower\", \"higher\",\n     *                             \"nearest\", \"midpoint\"\n     * @param {function} filter    Optional filter function used to clean data before aggregating\n     *\n     * @return {number}            The percentile\n     */\n\n  }, {\n    key: \"percentile\",\n    value: function percentile(q, fieldPath) {\n      var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n      var filter = arguments[3];\n      return this._collection.percentile(q, fieldPath, interp, filter);\n    }\n    /**\n     * Aggregates the events down using a user defined function to\n     * do the reduction.\n     *\n     * @param  {function} func    User defined reduction function. Will be\n     *                            passed a list of values. Should return a\n     *                            singe value.\n     * @param {string} fieldPath  Column to aggregate over. A deep value can\n     *                            be referenced with a string.like.this.  If not supplied\n     *                            the `value` column will be aggregated.\n     *\n     * @return {number}           The resulting value\n     */\n\n  }, {\n    key: \"aggregate\",\n    value: function aggregate(func, fieldPath) {\n      return this._collection.aggregate(func, fieldPath);\n    }\n    /**\n     * Gets n quantiles within the TimeSeries. This works the same way as numpy's percentile().\n     * For example `timeseries.quantile(4)` would be the same as using percentile with q = 0.25, 0.5 and 0.75.\n     *\n     * @param  {integer} n        The number of quantiles to divide the\n     *                            TimeSeries into.\n     * @param {string} fieldPath  Column to calculate over. A deep value can\n     *                            be referenced with a string.like.this.  If not supplied\n     *                            the `value` column will be aggregated.\n     * @param  {string} interp    Specifies the interpolation method\n     *                            to use when the desired quantile lies between\n     *                            two data points. Options are: \"linear\", \"lower\", \"higher\",\n     *                            \"nearest\", \"midpoint\".\n     * @return {array}            An array of n quantiles\n     */\n\n  }, {\n    key: \"quantile\",\n    value: function quantile(quantity) {\n      var fieldPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"value\";\n      var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n      return this._collection.quantile(quantity, fieldPath, interp);\n    }\n    /**\n     * Returns a new Pipeline with input source being initialized to\n     * this TimeSeries collection. This allows pipeline operations\n     * to be chained directly onto the TimeSeries to produce a new\n     * TimeSeries or event result.\n     *\n     * @example\n     *\n     * ```\n     * timeseries.pipeline()\n     *     .offsetBy(1)\n     *     .offsetBy(2)\n     *     .to(CollectionOut, c => out = c);\n     * ```\n     *\n     * @return {Pipeline} The Pipeline.\n     */\n\n  }, {\n    key: \"pipeline\",\n    value: function pipeline() {\n      return new _pipeline.Pipeline().from(this._collection);\n    }\n    /**\n     * Takes an operator that is used to remap events from this TimeSeries to\n     * a new set of events.\n     *\n     * @param  {function}   operator      An operator which will be passed each\n     *                                    event and which should return a new event.\n     * @return {TimeSeries}               A TimeSeries containing the remapped events\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(op) {\n      var collections = this.pipeline().map(op).toKeyedCollections();\n      return this.setCollection(collections[\"all\"], true);\n    }\n    /**\n     * Takes a fieldSpec (list of column names) and outputs to the callback just those\n     * columns in a new TimeSeries.\n     *\n     * @example\n     *\n     * ```\n     *     const ts = timeseries.select({fieldSpec: [\"uptime\", \"notes\"]});\n     * ```\n     *\n     * @param                options           An object containing options for the command\n     * @param {string|array} options.fieldSpec Column or columns to select into the new TimeSeries.\n     *                                         If you need to retrieve multiple deep nested values\n     *                                         that ['can.be', 'done.with', 'this.notation'].\n     *                                         A single deep value with a string.like.this.\n     *\n     * @return {TimeSeries}                    The resulting TimeSeries with renamed columns\n     */\n\n  }, {\n    key: \"select\",\n    value: function select(options) {\n      var fieldSpec = options.fieldSpec;\n      var collections = this.pipeline().select(fieldSpec).toKeyedCollections();\n      return this.setCollection(collections[\"all\"], true);\n    }\n    /**\n     * Takes a `fieldSpecList` (list of column names) and collapses\n     * them to a new column named `name` which is the reduction (using\n     * the `reducer` function) of the matched columns in the `fieldSpecList`.\n     *\n     * The column may be appended to the existing columns, or replace them,\n     * based on the `append` boolean.\n     *\n     * @example\n     *\n     * ```\n     *     const sums = ts.collapse({\n     *          name: \"sum_series\",\n     *          fieldSpecList: [\"in\", \"out\"],\n     *          reducer: sum(),\n     *          append: false\n     *     });\n     * ```\n     *\n     * @param                options                An object containing options:\n     * @param {array}        options.fieldSpecList  The list of columns to collapse. (required)\n     * @param {string}       options.name           The resulting collapsed column name (required)\n     * @param {function}     options.reducer        The reducer function (required)\n     * @param {bool}         options.append         Append the collapsed column, rather\n     *                                              than replace\n     *\n     * @return {TimeSeries}     The resulting collapsed TimeSeries\n     */\n\n  }, {\n    key: \"collapse\",\n    value: function collapse(options) {\n      var fieldSpecList = options.fieldSpecList,\n          name = options.name,\n          reducer = options.reducer,\n          append = options.append;\n      var collections = this.pipeline().collapse(fieldSpecList, name, reducer, append).toKeyedCollections();\n      return this.setCollection(collections[\"all\"], true);\n    }\n    /**\n     * Rename columns in the underlying events.\n     *\n     * Takes a object of columns to rename. Returns a new `TimeSeries` containing\n     * new events. Columns not in the dict will be retained and not renamed.\n     *\n     * @example\n     * ```\n     * new_ts = ts.renameColumns({\n     *     renameMap: {in: \"new_in\", out: \"new_out\"}\n     * });\n     * ```\n     *\n     * @note As the name implies, this will only rename the main\n     * \"top level\" (ie: non-deep) columns. If you need more\n     * extravagant renaming, roll your own using `TimeSeries.map()`.\n     *\n     * @param                options                An object containing options:\n     * @param {Object}       options.renameMap      Columns to rename.\n     *\n     * @return {TimeSeries}     The resulting TimeSeries with renamed columns\n     */\n\n  }, {\n    key: \"renameColumns\",\n    value: function renameColumns(options) {\n      var renameMap = options.renameMap;\n      return this.map(function (event) {\n        var eventType = event.type();\n        var d = event.data().mapKeys(function (key) {\n          return renameMap[key] || key;\n        });\n        return new eventType(event.key(), d);\n      });\n    }\n    /**\n     * Take the data in this TimeSeries and \"fill\" any missing or invalid\n     * values. This could be setting `null` values to zero so mathematical\n     * operations will succeed, interpolate a new value, or pad with the\n     * previously given value.\n     *\n     * The `fill()` method takes a single `options` arg.\n     *\n     * @example\n     * ```\n     * const filled = timeseries.fill({\n     *     fieldSpec: [\"direction.in\", \"direction.out\"],\n     *     method: \"zero\",\n     *     limit: 3\n     * });\n     * ```\n     *\n     * @param                options                An object containing options:\n     * @param {string|array} options.fieldSpec      Column or columns to fill. If you need to\n     *                                              retrieve multiple deep nested values\n     *                                              that ['can.be', 'done.with', 'this.notation'].\n     *                                              A single deep value with a string.like.this.\n     * @param {string}       options.method         \"linear\" or \"pad\" or \"zero\" style interpolation\n     * @param {number}       options.limit          The maximum number of points which should be\n     *                                              interpolated onto missing points. You might set this to\n     *                                              2 if you are willing to fill 2 new points,\n     *                                              and then beyond that leave data with missing values.\n     *\n     * @return {TimeSeries}                         The resulting filled TimeSeries\n     */\n\n  }, {\n    key: \"fill\",\n    value: function fill(options) {\n      var _options$fieldSpec = options.fieldSpec,\n          fieldSpec = _options$fieldSpec === undefined ? null : _options$fieldSpec,\n          _options$method = options.method,\n          method = _options$method === undefined ? \"zero\" : _options$method,\n          _options$limit = options.limit,\n          limit = _options$limit === undefined ? null : _options$limit;\n      var pipeline = this.pipeline();\n\n      if (method === \"zero\" || method === \"pad\") {\n        pipeline = pipeline.fill({\n          fieldSpec: fieldSpec,\n          method: method,\n          limit: limit\n        });\n      } else if (method === \"linear\" && _underscore2.default.isArray(fieldSpec)) {\n        fieldSpec.forEach(function (fieldPath) {\n          pipeline = pipeline.fill({\n            fieldSpec: fieldPath,\n            method: method,\n            limit: limit\n          });\n        });\n      } else {\n        throw new Error(\"Invalid fill method:\", method);\n      }\n\n      var collections = pipeline.toKeyedCollections();\n      return this.setCollection(collections[\"all\"], true);\n    }\n    /**\n     * Align event values to regular time boundaries. The value at\n     * the boundary is interpolated. Only the new interpolated\n     * points are returned. If limit is reached nulls will be\n     * returned at each boundary position.\n     *\n     * One use case for this is to modify irregular data (i.e. data\n     * that falls at slightly irregular times) so that it falls into a\n     * sequence of evenly spaced values. We use this to take data we\n     * get from the network which is approximately every 30 second\n     * (:32, 1:02, 1:34, ...) and output data on exact 30 second\n     * boundaries (:30, 1:00, 1:30, ...).\n     *\n     * Another use case is data that might be already aligned to\n     * some regular interval, but that contains missing points.\n     * While `fill()` can be used to replace `null` values, `align()`\n     * can be used to add in missing points completely. Those points\n     * can have an interpolated value, or by setting limit to 0,\n     * can be filled with nulls. This is really useful when downstream\n     * processing depends on complete sequences.\n     *\n     * @example\n     * ```\n     * const aligned = ts.align({\n     *     fieldSpec: \"value\",\n     *     period: \"1m\",\n     *     method: \"linear\"\n     * });\n     * ```\n     *\n     * @param                options                An object containing options:\n     * @param {string|array} options.fieldSpec      Column or columns to align. If you need to\n     *                                              retrieve multiple deep nested values\n     *                                              that ['can.be', 'done.with', 'this.notation'].\n     *                                              A single deep value with a string.like.this.\n     * @param {string}       options.period         Spacing of aligned values. e.g. \"6h\" or \"5m\"\n     * @param {string}       options.method         \"linear\" or \"pad\" style interpolation to boundaries.\n     * @param {number}       options.limit          The maximum number of points which should be\n     *                                              interpolated onto boundaries. You might set this to\n     *                                              2 if you are willing to interpolate 2 new points,\n     *                                              and then beyond that just emit nulls on the boundaries.\n     *\n     * @return {TimeSeries}     The resulting aligned TimeSeries\n     */\n\n  }, {\n    key: \"align\",\n    value: function align(options) {\n      var _options$fieldSpec2 = options.fieldSpec,\n          fieldSpec = _options$fieldSpec2 === undefined ? \"value\" : _options$fieldSpec2,\n          _options$period = options.period,\n          period = _options$period === undefined ? \"5m\" : _options$period,\n          _options$method2 = options.method,\n          method = _options$method2 === undefined ? \"linear\" : _options$method2,\n          _options$limit2 = options.limit,\n          limit = _options$limit2 === undefined ? null : _options$limit2;\n      var collection = this.pipeline().align(fieldSpec, period, method, limit).toKeyedCollections();\n      return this.setCollection(collection[\"all\"], true);\n    }\n    /**\n     * Returns the derivative of the TimeSeries for the given columns. The result will\n     * be per second. Optionally you can substitute in `null` values if the rate\n     * is negative. This is useful when a negative rate would be considered invalid.\n     *\n     * @param                options                An object containing options:\n     * @param {string|array} options.fieldSpec      Column or columns to get the rate of. If you\n     *                                              need to retrieve multiple deep nested values\n     *                                              that ['can.be', 'done.with', 'this.notation'].\n     * @param {bool}         options.allowNegative  Will output null values for negative rates.\n     *                                              This is useful if you are getting the rate\n     *                                              of a counter that always goes up, except\n     *                                              when perhaps it rolls around or resets.\n     *\n     * @return {TimeSeries}                         The resulting `TimeSeries` containing calculated rates.\n     */\n\n  }, {\n    key: \"rate\",\n    value: function rate() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$fieldSpec3 = options.fieldSpec,\n          fieldSpec = _options$fieldSpec3 === undefined ? \"value\" : _options$fieldSpec3,\n          _options$allowNegativ = options.allowNegative,\n          allowNegative = _options$allowNegativ === undefined ? true : _options$allowNegativ;\n      var collection = this.pipeline().rate(fieldSpec, allowNegative).toKeyedCollections();\n      return this.setCollection(collection[\"all\"], true);\n    }\n    /**\n     * Builds a new TimeSeries by dividing events within the TimeSeries\n     * across multiple fixed windows of size `windowSize`.\n     *\n     * Note that these are windows defined relative to Jan 1st, 1970,\n     * and are UTC, so this is best suited to smaller window sizes\n     * (hourly, 5m, 30s, 1s etc), or in situations where you don't care\n     * about the specific window, just that the data is smaller.\n     *\n     * Each window then has an aggregation specification applied as\n     * `aggregation`. This specification describes a mapping of output\n     * fieldNames to aggregation functions and their fieldPath. For example:\n     * ```\n     * { in_avg: { in: avg() }, out_avg: { out: avg() } }\n     * ```\n     * will aggregate both \"in\" and \"out\" using the average aggregation\n     * function and return the result as in_avg and out_avg.\n     *\n     * Note that each aggregation function, such as `avg()` also can take a\n     * filter function to apply before the aggregation. A set of filter functions\n     * exists to do common data cleanup such as removing bad values. For example:\n     * ```\n     * { value_avg: { value: avg(filter.ignoreMissing) } }\n     * ```\n     *\n     * @example\n     * ```\n     *     const timeseries = new TimeSeries(data);\n     *     const dailyAvg = timeseries.fixedWindowRollup({\n     *         windowSize: \"1d\",\n     *         aggregation: {value: {value: avg()}}\n     *     });\n     * ```\n     *\n     * @param                options                An object containing options:\n     * @param {string}       options.windowSize     The size of the window. e.g. \"6h\" or \"5m\"\n     * @param {object}       options.aggregation    The aggregation specification (see description above)\n     * @param {bool}         options.toTimeEvents   Output as `TimeEvent`s, rather than `IndexedEvent`s\n     * @return {TimeSeries}                         The resulting rolled up `TimeSeries`\n     */\n\n  }, {\n    key: \"fixedWindowRollup\",\n    value: function fixedWindowRollup(options) {\n      var windowSize = options.windowSize,\n          aggregation = options.aggregation,\n          _options$toTimeEvents = options.toTimeEvents,\n          toTimeEvents = _options$toTimeEvents === undefined ? false : _options$toTimeEvents;\n\n      if (!windowSize) {\n        throw new Error(\"windowSize must be supplied, for example '5m' for five minute rollups\");\n      }\n\n      if (!aggregation || !_underscore2.default.isObject(aggregation)) {\n        throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n      }\n\n      var aggregatorPipeline = this.pipeline().windowBy(windowSize).emitOn(\"discard\").aggregate(aggregation);\n      var eventTypePipeline = toTimeEvents ? aggregatorPipeline.asTimeEvents() : aggregatorPipeline;\n      var collections = eventTypePipeline.clearWindow().toKeyedCollections();\n      return this.setCollection(collections[\"all\"], true);\n    }\n    /**\n     * Builds a new TimeSeries by dividing events into hours.\n     *\n     * Each window then has an aggregation specification `aggregation`\n     * applied. This specification describes a mapping of output\n     * fieldNames to aggregation functions and their fieldPath. For example:\n     * ```\n     * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n     * ```\n     *\n     * @param                options                An object containing options:\n     * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n     *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n     * @param {object}       options.aggregation    The aggregation specification (see description above)\n     *\n     * @return {TimeSeries}     The resulting rolled up TimeSeries\n     */\n\n  }, {\n    key: \"hourlyRollup\",\n    value: function hourlyRollup(options) {\n      var aggregation = options.aggregation,\n          _options$toTimeEvents2 = options.toTimeEvents,\n          toTimeEvents = _options$toTimeEvents2 === undefined ? false : _options$toTimeEvents2;\n\n      if (!aggregation || !_underscore2.default.isObject(aggregation)) {\n        throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n      }\n\n      return this.fixedWindowRollup(\"1h\", aggregation, toTimeEvents);\n    }\n    /**\n     * Builds a new TimeSeries by dividing events into days.\n     *\n     * Each window then has an aggregation specification `aggregation`\n     * applied. This specification describes a mapping of output\n     * fieldNames to aggregation functions and their fieldPath. For example:\n     * ```\n     * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n     * ```\n     *\n     * @param                options                An object containing options:\n     * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n     *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n     * @param {object}       options.aggregation    The aggregation specification (see description above)\n     *\n     * @return {TimeSeries}     The resulting rolled up TimeSeries\n     */\n\n  }, {\n    key: \"dailyRollup\",\n    value: function dailyRollup(options) {\n      var aggregation = options.aggregation,\n          _options$toTimeEvents3 = options.toTimeEvents,\n          toTimeEvents = _options$toTimeEvents3 === undefined ? false : _options$toTimeEvents3;\n\n      if (!aggregation || !_underscore2.default.isObject(aggregation)) {\n        throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n      }\n\n      return this._rollup(\"daily\", aggregation, toTimeEvents);\n    }\n    /**\n     * Builds a new TimeSeries by dividing events into months.\n     *\n     * Each window then has an aggregation specification `aggregation`\n     * applied. This specification describes a mapping of output\n     * fieldNames to aggregation functions and their fieldPath. For example:\n     * ```\n     * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n     * ```\n     *\n     * @param                options                An object containing options:\n     * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n     *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n     * @param {object}       options.aggregation    The aggregation specification (see description above)\n     *\n     * @return {TimeSeries}                         The resulting rolled up `TimeSeries`\n     */\n\n  }, {\n    key: \"monthlyRollup\",\n    value: function monthlyRollup(options) {\n      var aggregation = options.aggregation,\n          _options$toTimeEvents4 = options.toTimeEvents,\n          toTimeEvents = _options$toTimeEvents4 === undefined ? false : _options$toTimeEvents4;\n\n      if (!aggregation || !_underscore2.default.isObject(aggregation)) {\n        throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n      }\n\n      return this._rollup(\"monthly\", aggregation, toTimeEvents);\n    }\n    /**\n     * Builds a new TimeSeries by dividing events into years.\n     *\n     * Each window then has an aggregation specification `aggregation`\n     * applied. This specification describes a mapping of output\n     * fieldNames to aggregation functions and their fieldPath. For example:\n     *\n     * ```\n     * {in_avg: {in: avg()}, out_avg: {out: avg()}}\n     * ```\n     *\n     * @param                options                An object containing options:\n     * @param {bool}         options.toTimeEvents   Convert the rollup events to `TimeEvent`s, otherwise it\n     *                                              will be returned as a `TimeSeries` of `IndexedEvent`s.\n     * @param {object}       options.aggregation    The aggregation specification (see description above)\n     *\n     * @return {TimeSeries}                         The resulting rolled up `TimeSeries`\n     */\n\n  }, {\n    key: \"yearlyRollup\",\n    value: function yearlyRollup(options) {\n      var aggregation = options.aggregation,\n          _options$toTimeEvents5 = options.toTimeEvents,\n          toTimeEvents = _options$toTimeEvents5 === undefined ? false : _options$toTimeEvents5;\n\n      if (!aggregation || !_underscore2.default.isObject(aggregation)) {\n        throw new Error(\"aggregation object must be supplied, for example: {value: {value: avg()}}\");\n      }\n\n      return this._rollup(\"yearly\", aggregation, toTimeEvents);\n    }\n    /**\n     * @private\n     *\n     * Internal function to build the TimeSeries rollup functions using\n     * an aggregator Pipeline.\n     */\n\n  }, {\n    key: \"_rollup\",\n    value: function _rollup(type, aggregation) {\n      var toTimeEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var aggregatorPipeline = this.pipeline().windowBy(type).emitOn(\"discard\").aggregate(aggregation);\n      var eventTypePipeline = toTimeEvents ? aggregatorPipeline.asTimeEvents() : aggregatorPipeline;\n      var collections = eventTypePipeline.clearWindow().toKeyedCollections();\n      return this.setCollection(collections[\"all\"], true);\n    }\n    /**\n     * Builds multiple `Collection`s, each collects together\n     * events within a window of size `windowSize`. Note that these\n     * are windows defined relative to Jan 1st, 1970, and are UTC.\n     *\n     * @example\n     * ```\n     * const timeseries = new TimeSeries(data);\n     * const collections = timeseries.collectByFixedWindow({windowSize: \"1d\"});\n     * console.log(collections); // {1d-16314: Collection, 1d-16315: Collection, ...}\n     * ```\n     *\n     * @param                options                An object containing options:\n     * @param {bool}         options.windowSize     The size of the window. e.g. \"6h\" or \"5m\"\n     *\n     * @return {map}    The result is a mapping from window index to a Collection.\n     */\n\n  }, {\n    key: \"collectByFixedWindow\",\n    value: function collectByFixedWindow(_ref) {\n      var windowSize = _ref.windowSize;\n      return this.pipeline().windowBy(windowSize).emitOn(\"discard\").toKeyedCollections();\n    }\n    /*\n     * STATIC\n     */\n\n    /**\n     * Defines the event type contained in this TimeSeries. The default here\n     * is to use the supplied type (time, timerange or index) to build either\n     * a TimeEvent, TimeRangeEvent or IndexedEvent. However, you can also\n     * subclass the TimeSeries and reimplement this to return another event\n     * type.\n     */\n\n  }], [{\n    key: \"event\",\n    value: function event(eventKey) {\n      switch (eventKey) {\n        case \"time\":\n          return _timeevent2.default;\n\n        case \"timerange\":\n          return _timerangeevent2.default;\n\n        case \"index\":\n          return _indexedevent2.default;\n\n        default:\n          throw new Error(\"Unknown event type: \" + eventKey);\n      }\n    }\n    /**\n     * Static function to compare two TimeSeries to each other. If the TimeSeries\n     * are of the same instance as each other then equals will return true.\n     * @param  {TimeSeries} series1\n     * @param  {TimeSeries} series2\n     * @return {bool} result\n     */\n\n  }, {\n    key: \"equal\",\n    value: function equal(series1, series2) {\n      return series1._data === series2._data && series1._collection === series2._collection;\n    }\n    /**\n     * Static function to compare two TimeSeries to each other. If the TimeSeries\n     * are of the same value as each other then equals will return true.\n     * @param  {TimeSeries} series1\n     * @param  {TimeSeries} series2\n     * @return {bool} result\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(series1, series2) {\n      return _immutable2.default.is(series1._data, series2._data) && _collection2.default.is(series1._collection, series2._collection);\n    }\n    /**\n     * Reduces a list of TimeSeries objects using a reducer function. This works\n     * by taking each event in each TimeSeries and collecting them together\n     * based on timestamp. All events for a given time are then merged together\n     * using the reducer function to produce a new event. The reducer function is\n     * applied to all columns in the fieldSpec. Those new events are then\n     * collected together to form a new TimeSeries.\n     *\n     * @example\n     *\n     * For example you might have three TimeSeries with columns \"in\" and \"out\" which\n     * corresponds to two measurements per timestamp. You could use this function to\n     * obtain a new TimeSeries which was the sum of the the three measurements using\n     * the `sum()` reducer function and an [\"in\", \"out\"] fieldSpec.\n     *\n     * ```\n     * const totalSeries = TimeSeries.timeSeriesListReduce({\n     *     name: \"totals\",\n     *     seriesList: [inTraffic, outTraffic],\n     *     reducer: sum(),\n     *     fieldSpec: [ \"in\", \"out\" ]\n     * });\n     * ```\n     *\n     * @param                  options                An object containing options. Additional key\n     *                                                values in the options will be added as meta data\n     *                                                to the resulting TimeSeries.\n     * @param {array}          options.seriesList     A list of `TimeSeries` (required)\n     * @param {function}       options.reducer        The reducer function e.g. `max()` (required)\n     * @param {array | string} options.fieldSpec      Column or columns to reduce. If you\n     *                                                need to retrieve multiple deep\n     *                                                nested values that ['can.be', 'done.with',\n     *                                                'this.notation']. A single deep value with a\n     *                                                string.like.this.\n     *\n     * @return {TimeSeries}                           The reduced TimeSeries\n     */\n\n  }, {\n    key: \"timeSeriesListReduce\",\n    value: function timeSeriesListReduce(options) {\n      var fieldSpec = options.fieldSpec,\n          reducer = options.reducer,\n          data = (0, _objectWithoutProperties3.default)(options, [\"fieldSpec\", \"reducer\"]);\n\n      var combiner = _event2.default.combiner(fieldSpec, reducer);\n\n      return TimeSeries.timeSeriesListEventReduce((0, _extends3.default)({\n        fieldSpec: fieldSpec,\n        reducer: combiner\n      }, data));\n    }\n    /**\n     * Takes a list of TimeSeries and merges them together to form a new\n     * Timeseries.\n     *\n     * Merging will produce a new Event;\n    only when events are conflict free, so\n     * it is useful in the following cases:\n     *  * to combine multiple TimeSeries which have different time ranges, essentially\n     *  concatenating them together\n     *  * combine TimeSeries which have different columns, for example inTraffic has\n     *  a column \"in\" and outTraffic has a column \"out\" and you want to produce a merged\n     *  trafficSeries with columns \"in\" and \"out\".\n     *\n     * @example\n     * ```\n     * const inTraffic = new TimeSeries(trafficDataIn);\n     * const outTraffic = new TimeSeries(trafficDataOut);\n     * const trafficSeries = TimeSeries.timeSeriesListMerge({\n     *     name: \"traffic\",\n     *     seriesList: [inTraffic, outTraffic]\n     * });\n     * ```\n     *\n     * @param                  options                An object containing options. Additional key\n     *                                                values in the options will be added as meta data\n     *                                                to the resulting TimeSeries.\n     * @param {array}          options.seriesList     A list of `TimeSeries` (required)\n     * @param {array | string} options.fieldSpec      Column or columns to merge. If you\n     *                                                need to retrieve multiple deep\n     *                                                nested values that ['can.be', 'done.with',\n     *                                                'this.notation']. A single deep value with a\n     *                                                string.like.this.\n     *\n     * @return {TimeSeries}                           The merged TimeSeries\n     */\n\n  }, {\n    key: \"timeSeriesListMerge\",\n    value: function timeSeriesListMerge(options) {\n      var fieldSpec = options.fieldSpec,\n          data = (0, _objectWithoutProperties3.default)(options, [\"fieldSpec\"]);\n\n      var merger = _event2.default.merger(fieldSpec);\n\n      return TimeSeries.timeSeriesListEventReduce((0, _extends3.default)({\n        fieldSpec: fieldSpec,\n        reducer: merger\n      }, data));\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"timeSeriesListEventReduce\",\n    value: function timeSeriesListEventReduce(options) {\n      var seriesList = options.seriesList,\n          fieldSpec = options.fieldSpec,\n          reducer = options.reducer,\n          data = (0, _objectWithoutProperties3.default)(options, [\"seriesList\", \"fieldSpec\", \"reducer\"]);\n\n      if (!seriesList || !_underscore2.default.isArray(seriesList)) {\n        throw new Error(\"A list of TimeSeries must be supplied to reduce\");\n      }\n\n      if (!reducer || !_underscore2.default.isFunction(reducer)) {\n        throw new Error(\"reducer function must be supplied, for example avg()\");\n      } // for each series, make a map from timestamp to the\n      // list of events with that timestamp\n\n\n      var eventList = [];\n      seriesList.forEach(function (series) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = (0, _getIterator3.default)(series.events()), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var event = _step3.value;\n            eventList.push(event);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      });\n      var events = reducer(eventList, fieldSpec); // Make a collection. If the events are out of order, sort them.\n      // It's always possible that events are out of order here, depending\n      // on the start times of the series, along with it the series\n      // have missing data, so I think we don't have a choice here.\n\n      var collection = new _collection2.default(events);\n\n      if (!collection.isChronological()) {\n        collection = collection.sortByTime();\n      }\n\n      var timeseries = new TimeSeries((0, _extends3.default)({}, data, {\n        collection: collection\n      }));\n      return timeseries;\n    }\n  }]);\n  return TimeSeries;\n}();\n\nexports.default = TimeSeries;","map":null,"metadata":{},"sourceType":"script"}