{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getPrototypeOf = require(\"babel-runtime/core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _immutable = require(\"immutable\");\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nvar _bounded = require(\"./io/bounded\");\n\nvar _bounded2 = _interopRequireDefault(_bounded);\n\nvar _event = require(\"./event\");\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _timerange = require(\"./timerange\");\n\nvar _timerange2 = _interopRequireDefault(_timerange);\n\nvar _util = require(\"./base/util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _functions = require(\"./base/functions\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A collection is an abstraction for a bag of Events.\n *\n * You typically construct a Collection from a list of Events, which\n * may be either within an Immutable.List or an Array. You can also\n * copy another Collection or create an empty one.\n *\n * You can mutate a collection in a number of ways. In each instance\n * a new Collection will be returned.\n *\n * Basic operations on the list of events are also possible. You\n * can iterate over the collection with a for..of loop, get the size()\n * of the collection and access a specific element with at().\n *\n * You can also perform aggregations of the events, map them, filter them\n * clean them, etc.\n *\n * Collections form the backing structure for a TimeSeries, as well as\n * in Pipeline event processing. They are an instance of a BoundedIn, so\n * they can be used as a pipeline source.\n */\n\n\nvar Collection = function (_Bounded) {\n  (0, _inherits3.default)(Collection, _Bounded);\n  /**\n   * Construct a new Collection.\n   *\n   * @param  {Collection|array|Immutable.List}  arg1 Initial data for\n   * the collection. If arg1 is another Collection, this will act as\n   * a copy constructor.\n   * @param  {Boolean} [arg2] When using a the copy constructor\n   * this specified whether or not to also copy all the events in this\n   * collection. Generally you'll want to let it copy the events.\n   * If arg1 is an Immutable.List, then arg2 will specify the type of\n   * the Events accepted into the Collection. This form is generally\n   * used internally.\n   *\n   * @return {Collection} The constructed Collection.\n   */\n\n  function Collection(arg1, arg2) {\n    (0, _classCallCheck3.default)(this, Collection);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Collection.__proto__ || (0, _getPrototypeOf2.default)(Collection)).call(this));\n\n    _this._id = _underscore2.default.uniqueId(\"collection-\");\n    _this._eventList = null; // The events in this collection\n\n    _this._type = null; // The type (class) of the events in this collection\n\n    if (!arg1) {\n      _this._eventList = new _immutable2.default.List();\n    } else if (arg1 instanceof Collection) {\n      var other = arg1;\n      var copyEvents = arg2 || true; // copyEvents is whether to copy events from other, default is true\n\n      if (_underscore2.default.isUndefined(copyEvents) || copyEvents === true) {\n        _this._eventList = other._eventList;\n        _this._type = other._type;\n      } else {\n        _this._eventList = new _immutable2.default.List();\n      }\n    } else if (_underscore2.default.isArray(arg1)) {\n      var events = [];\n      arg1.forEach(function (e) {\n        _this._check(e);\n\n        events.push(e._d);\n      });\n      _this._eventList = new _immutable2.default.List(events);\n    } else if (_immutable2.default.List.isList(arg1)) {\n      var type = arg2;\n\n      if (!type) {\n        throw new Error(\"No type supplied to Collection constructor\");\n      }\n\n      _this._type = type;\n      _this._eventList = arg1;\n    }\n\n    return _this;\n  }\n  /**\n   * Returns the Collection as a regular JSON object.\n   *\n   * @return {Object} The JSON representation of this Collection\n   */\n\n\n  (0, _createClass3.default)(Collection, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._eventList.toJS();\n    }\n    /**\n     * Serialize out the Collection as a string. This will be the\n     * string representation of `toJSON()`.\n     *\n     * @return {string} The Collection serialized as a string.\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return (0, _stringify2.default)(this.toJSON());\n    }\n    /**\n     * Returns the Event object type in this Collection.\n     *\n     * Since Collections may only have one type of event (`Event`, `IndexedEvent`\n     * or `TimeRangeEvent`) this will return that type. If no events\n     * have been added to the Collection it will return `undefined`.\n     *\n     * @return {Event} - The class of the type of events contained in\n     *                   this Collection.\n     */\n\n  }, {\n    key: \"type\",\n    value: function type() {\n      return this._type;\n    }\n    /**\n     * Returns the number of events in this collection\n     *\n     * @return {number} Count of events\n     */\n\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this._eventList.size;\n    }\n    /**\n     * Returns the number of valid items in this collection.\n     *\n     * Uses the fieldPath to look up values in all events.\n     * It then counts the number that are considered valid, which\n     * specifically are not NaN, undefined or null.\n     *\n     * @return {number} Count of valid events\n     */\n\n  }, {\n    key: \"sizeValid\",\n    value: function sizeValid() {\n      var fieldPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"value\";\n      var count = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)(this.events()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var e = _step.value;\n          if (_event2.default.isValidValue(e, fieldPath)) count++;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return count;\n    }\n    /**\n     * Returns an event in the Collection by its position.\n     * @example\n     * ```\n     * for (let row=0; row < series.size(); row++) {\n     *   const event = series.at(row);\n     *   console.log(event.toString());\n     * }\n     * ```\n     * @param  {number} pos The position of the event\n     * @return {Event}      Returns the event at the pos specified.\n     */\n\n  }, {\n    key: \"at\",\n    value: function at(pos) {\n      if (this._eventList.size > 0) {\n        var event = new this._type(this._eventList.get(pos));\n        return event;\n      }\n    }\n    /**\n     * Returns a list of events in the Collection which have\n     * the exact key (time, timerange or index) as the key specified\n     * by 'at'. Note that this is an O(n) search for the time specified,\n     * since collections are an unordered bag of events.\n     *\n     * @param  {Date|string|TimeRange} key The key of the event.\n     * @return {Array} All events at that key\n     */\n\n  }, {\n    key: \"atKey\",\n    value: function atKey(k) {\n      var result = [];\n      var key = void 0;\n\n      if (k instanceof Date) {\n        key = k.getTime();\n      } else if (_underscore2.default.isString(k)) {\n        key = k;\n      } else if (k instanceof _timerange2.default) {\n        key = this.timerange().begin() + \",\" + this.timerange().end();\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = (0, _getIterator3.default)(this.events()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var e = _step2.value;\n\n          if (e.key() === key) {\n            result.push(e);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Returns the first event in the Collection.\n     *\n     * @return {Event}\n     */\n\n  }, {\n    key: \"atFirst\",\n    value: function atFirst() {\n      if (this.size()) {\n        return this.at(0);\n      }\n    }\n    /**\n     * Returns the last event in the Collection.\n     *\n     * @return {Event}\n     */\n\n  }, {\n    key: \"atLast\",\n    value: function atLast() {\n      if (this.size()) {\n        return this.at(this.size() - 1);\n      }\n    }\n    /**\n     * Generator to return all the events in the Collection.\n     *\n     * @example\n     * ```\n     * for (let event of collection.events()) {\n     *     console.log(event.toString());\n     * }\n     * ```\n     */\n\n  }, {\n    key: \"events\",\n    value:\n    /*#__PURE__*/\n    _regenerator2.default.mark(function events() {\n      var i;\n      return _regenerator2.default.wrap(function events$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              i = 0;\n\n            case 1:\n              if (!(i < this.size())) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 4;\n              return this.at(i);\n\n            case 4:\n              i++;\n              _context.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, events, this);\n    })\n  }, {\n    key: \"setEvents\",\n    value: function setEvents(events) {\n      var result = new Collection(this);\n      result._eventList = events;\n      return result;\n    }\n    /**\n     * Returns the raw Immutable event list\n     *\n     * @return {Immutable.List} All events as an Immutable List.\n     */\n\n  }, {\n    key: \"eventList\",\n    value: function eventList() {\n      return this._eventList;\n    }\n    /**\n     * Returns a Javascript array representation of the event list\n     *\n     * @return {Array} All events as a Javascript Array.\n     */\n\n  }, {\n    key: \"eventListAsArray\",\n    value: function eventListAsArray() {\n      var events = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = (0, _getIterator3.default)(this.events()), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var e = _step3.value;\n          events.push(e);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return events;\n    }\n    /**\n     * Returns the events in the collection as a Javascript Map, where\n     * the key is the timestamp, index or timerange and the\n     * value is an array of events with that key.\n     *\n     * @return {map} The map of events\n     */\n\n  }, {\n    key: \"eventListAsMap\",\n    value: function eventListAsMap() {\n      var events = {};\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = (0, _getIterator3.default)(this.events()), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var e = _step4.value;\n          var key = e.key();\n\n          if (!_underscore2.default.has(events, key)) {\n            events[key] = [];\n          }\n\n          events[key].push(e);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return events;\n    } //\n    // De-duplicate\n    //\n\n    /**\n     * Removes duplicates from the Collection. If duplicates\n     * exist in the collection with the same key but with different\n     * values, then later event values will be used.\n     *\n     * @return {Collection} The sorted Collection.\n     */\n\n  }, {\n    key: \"dedup\",\n    value: function dedup() {\n      var events = _event2.default.merge(this.eventListAsArray());\n\n      return new Collection(events);\n    } //\n    // Sorting\n    //\n\n    /**\n     * Sorts the Collection by the timestamp. In the case\n     * of TimeRangeEvents and IndexedEvents, it will be sorted\n     * by the begin time. This is useful when the collection\n     * will be passed into a TimeSeries.\n     *\n     * See also isChronological().\n     *\n     * @return {Collection} The sorted Collection\n     */\n\n  }, {\n    key: \"sortByTime\",\n    value: function sortByTime() {\n      var _this2 = this;\n\n      var sorted = this._eventList.sortBy(function (event) {\n        var e = new _this2._type(event);\n        return e.timestamp().getTime();\n      });\n\n      return this.setEvents(sorted);\n    }\n    /**\n     * Sorts the Collection using the value referenced by\n     * the fieldPath.\n     *\n     * @return {Collection} The extents of the Collection\n     */\n\n  }, {\n    key: \"sort\",\n    value: function sort(fieldPath) {\n      var _this3 = this;\n\n      var fs = _util2.default.fieldPathToArray(fieldPath);\n\n      var sorted = this._eventList.sortBy(function (event) {\n        var e = new _this3._type(event);\n        return e.get(fs);\n      });\n\n      return this.setEvents(sorted);\n    } //\n    // Series range\n    //\n\n    /**\n     * From the range of times, or Indexes within the TimeSeries, return\n     * the extents of the TimeSeries as a TimeRange. This is currently implemented\n     * by walking the events.\n     *\n     * @return {TimeRange} The extents of the TimeSeries\n     */\n\n  }, {\n    key: \"range\",\n    value: function range() {\n      var min = void 0;\n      var max = void 0;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = (0, _getIterator3.default)(this.events()), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var e = _step5.value;\n          if (!min || e.begin() < min) min = e.begin();\n          if (!max || e.end() > max) max = e.end();\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      if (min && max) return new _timerange2.default(min, max);\n    } //\n    // Collection mutation\n    //\n\n    /**\n     * Adds an event to the collection, returns a new Collection. The event added\n     * can be an Event, TimeRangeEvent or IndexedEvent, but it must be of the\n     * same type as other events within the Collection.\n     *\n     * @param {Event} event The event being added.\n     *\n     * @return {Collection} A new, modified, Collection containing the new event.\n     */\n\n  }, {\n    key: \"addEvent\",\n    value: function addEvent(event) {\n      this._check(event);\n\n      var result = new Collection(this);\n      result._eventList = this._eventList.push(event._d);\n      return result;\n    }\n    /**\n     * Perform a slice of events within the Collection, returns a new\n     * Collection representing a portion of this TimeSeries from begin up to\n     * but not including end.\n     *\n     * @param {Number} begin   The position to begin slicing\n     * @param {Number} end     The position to end slicing\n     *\n     * @return {Collection}    The new, sliced, Collection.\n     */\n\n  }, {\n    key: \"slice\",\n    value: function slice(begin, end) {\n      return new Collection(this._eventList.slice(begin, end), this._type);\n    }\n    /**\n     * Filter the collection's event list with the supplied function\n     *\n     * @param {function} func The filter function, that should return\n     *                        true or false when passed in an event.\n     *\n     * @return {Collection}   A new, filtered, Collection.\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(filterFunc) {\n      var filteredEventList = [];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = (0, _getIterator3.default)(this.events()), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var e = _step6.value;\n\n          if (filterFunc(e)) {\n            filteredEventList.push(e);\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return new Collection(filteredEventList);\n    }\n    /**\n     * Map the collection's event list to a new event list with\n     * the supplied function.\n     * @param {function} func The mapping function, that should return\n     * a new event when passed in the old event.\n     *\n     * @return {Collection} A new, modified, Collection.\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(mapFunc) {\n      var result = [];\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = (0, _getIterator3.default)(this.events()), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var e = _step7.value;\n          result.push(mapFunc(e));\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return new Collection(result);\n    }\n    /**\n     * Returns a new Collection by testing the fieldPath\n     * values for being valid (not NaN, null or undefined).\n     *\n     * The resulting Collection will be clean (for that fieldPath).\n     *\n     * @param  {string}      fieldPath  Name of value to look up. If not supplied,\n     *                                  defaults to ['value']. \"Deep\" syntax is\n     *                                  ['deep', 'value'] or 'deep.value'\n     *\n     * @return {Collection}             A new, modified, Collection.\n     */\n\n  }, {\n    key: \"clean\",\n    value: function clean(fieldPath) {\n      var fs = _util2.default.fieldPathToArray(fieldPath);\n\n      var filteredEvents = [];\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = (0, _getIterator3.default)(this.events()), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var e = _step8.value;\n\n          if (_event2.default.isValidValue(e, fs)) {\n            filteredEvents.push(e);\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      return new Collection(filteredEvents);\n    } //\n    // Aggregate the event list to a single value\n    //\n\n    /**\n     * Returns the number of events in this collection\n     *\n     * @return {number} The number of events\n     */\n\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this.size();\n    }\n    /**\n     * Returns the first value in the Collection for the fieldspec\n     *\n     * @param {string} fieldPath  Column to find the first value of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The first value\n     */\n\n  }, {\n    key: \"first\",\n    value: function first(fieldPath, filter) {\n      return this.aggregate((0, _functions.first)(filter), fieldPath);\n    }\n    /**\n     * Returns the last value in the Collection for the fieldspec\n     *\n     * @param {string} fieldPath  Column to find the last value of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The last value\n     */\n\n  }, {\n    key: \"last\",\n    value: function last(fieldPath, filter) {\n      return this.aggregate((0, _functions.last)(filter), fieldPath);\n    }\n    /**\n     * Returns the sum of the Collection for the fieldspec\n     *\n     * @param {string} fieldPath  Column to find the sum of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The sum\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum(fieldPath, filter) {\n      return this.aggregate((0, _functions.sum)(filter), fieldPath);\n    }\n    /**\n     * Aggregates the events down to their average(s)\n     *\n     * @param {string} fieldPath  Column to find the avg of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The average\n     */\n\n  }, {\n    key: \"avg\",\n    value: function avg(fieldPath, filter) {\n      return this.aggregate((0, _functions.avg)(filter), fieldPath);\n    }\n    /**\n     * Aggregates the events down to their maximum value\n     *\n     * @param {string} fieldPath  Column to find the max of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The max value for the field\n     */\n\n  }, {\n    key: \"max\",\n    value: function max(fieldPath, filter) {\n      return this.aggregate((0, _functions.max)(filter), fieldPath);\n    }\n    /**\n     * Aggregates the events down to their minimum value\n     *\n     * @param {string} fieldPath  Column to find the min of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The min value for the field\n     */\n\n  }, {\n    key: \"min\",\n    value: function min(fieldPath, filter) {\n      return this.aggregate((0, _functions.min)(filter), fieldPath);\n    }\n    /**\n     * Aggregates the events down to their mean (same as avg)\n     *\n     * @param {string} fieldPath  Column to find the mean of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The mean\n     */\n\n  }, {\n    key: \"mean\",\n    value: function mean(fieldPath, filter) {\n      return this.avg(fieldPath, filter);\n    }\n    /**\n     * Aggregates the events down to their minimum value\n     *\n     * @param {string} fieldPath  Column to find the median of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The median value\n     */\n\n  }, {\n    key: \"median\",\n    value: function median(fieldPath, filter) {\n      return this.aggregate((0, _functions.median)(filter), fieldPath);\n    }\n    /**\n     * Aggregates the events down to their stdev\n     *\n     * @param {string} fieldPath  Column to find the stdev of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The resulting stdev value\n     */\n\n  }, {\n    key: \"stdev\",\n    value: function stdev(fieldPath, filter) {\n      return this.aggregate((0, _functions.stdev)(filter), fieldPath);\n    }\n    /**\n     * Gets percentile q within the Collection. This works the same way as numpy.\n     *\n     * @param  {integer} q        The percentile (should be between 0 and 100)\n     *\n     * @param {string} fieldPath  Column to find the percentile of. A deep value can be referenced with a\n     *                            string.like.this.  If not supplied the `value` column will be\n     *                            aggregated.\n     *\n     * @param  {string} interp    Specifies the interpolation method\n     *                            to use when the desired quantile lies between\n     *                            two data points. Options are:\n     *                            options are:\n     *                             * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n     *                             * lower: i.\n     *                             * higher: j.\n     *                             * nearest: i or j whichever is nearest.\n     *                             * midpoint: (i + j) / 2.\n     * @param {function} filter   Optional filter function used to clean data before aggregating\n     *\n     * @return {number}           The percentile\n     */\n\n  }, {\n    key: \"percentile\",\n    value: function percentile(q, fieldPath) {\n      var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n      var filter = arguments[3];\n      return this.aggregate((0, _functions.percentile)(q, interp, filter), fieldPath);\n    }\n    /**\n     * Aggregates the events down using a user defined function to\n     * do the reduction.\n     *\n     * @param  {function} func    User defined reduction function. Will be\n     *                            passed a list of values. Should return a\n     *                            singe value.\n     *\n     * @param  {String} fieldPath The field to aggregate over\n     *\n     * @return {number}           The resulting value\n     */\n\n  }, {\n    key: \"aggregate\",\n    value: function aggregate(func, fieldPath) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fpath = void 0;\n\n      if (!_underscore2.default.isFunction(func)) {\n        throw new Error(\"First arg to aggregate() must be a function\");\n      }\n\n      if (_underscore2.default.isString(fieldPath)) {\n        fpath = fieldPath;\n      } else if (_underscore2.default.isArray(fieldPath)) {\n        // if the ['array', 'style', 'fieldpath'] is being used,\n        // we need to turn it back into a string since we are\n        // using a subset of the the map() functionality on\n        // a single column\n        fpath = fieldPath.split(\".\");\n      } else if (_underscore2.default.isUndefined(fieldPath)) {\n        // map() needs a field name to use as a key. Normally\n        // this case is normally handled by _field_spec_to_array()\n        // inside get(). Also, if map(func, field_spec=None) then\n        // it will map all the columns.\n        fpath = \"value\";\n      } else {\n        throw new Error(\"Collection.aggregate() takes a string/array fieldPath\");\n      }\n\n      var result = _event2.default.mapReduce(this.eventListAsArray(), fpath, func, options);\n\n      return result[fpath];\n    }\n    /**\n     * Gets n quantiles within the Collection. This works the same way as numpy.\n     *\n     * @param  {integer} n        The number of quantiles to divide the\n     *                            Collection into.\n     *\n     * @param  {string} column    The field to return as the quantile\n     *\n     * @param  {string} interp    Specifies the interpolation method\n     *                            to use when the desired quantile lies between\n     *                            two data points. Options are:\n     *                            options are:\n     *                             * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n     *                             * lower: i.\n     *                             * higher: j.\n     *                             * nearest: i or j whichever is nearest.\n     *                             * midpoint: (i + j) / 2.\n     *\n     * @return {array}            An array of n quantiles\n     */\n\n  }, {\n    key: \"quantile\",\n    value: function quantile(n) {\n      var column = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"value\";\n      var interp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"linear\";\n      var results = [];\n      var sorted = this.sort(column);\n      var subsets = 1.0 / n;\n\n      if (n > this.length) {\n        throw new Error(\"Subset n is greater than the Collection length\");\n      }\n\n      for (var i = subsets; i < 1; i += subsets) {\n        var index = Math.floor((sorted.size() - 1) * i);\n\n        if (index < sorted.size() - 1) {\n          var fraction = (sorted.size() - 1) * i - index;\n          var v0 = sorted.at(index).get(column);\n          var v1 = sorted.at(index + 1).get(column);\n          var v = void 0;\n\n          if (interp === \"lower\" || fraction === 0) {\n            v = v0;\n          } else if (interp === \"linear\") {\n            v = v0 + (v1 - v0) * fraction;\n          } else if (interp === \"higher\") {\n            v = v1;\n          } else if (interp === \"nearest\") {\n            v = fraction < 0.5 ? v0 : v1;\n          } else if (interp === \"midpoint\") {\n            v = (v0 + v1) / 2;\n          }\n\n          results.push(v);\n        }\n      }\n\n      return results;\n    }\n    /**\n     * Returns true if all events in this Collection are in chronological order.\n     * @return {Boolean} True if all events are in order, oldest events to newest.\n     */\n\n  }, {\n    key: \"isChronological\",\n    value: function isChronological() {\n      var result = true;\n      var t = void 0;\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = (0, _getIterator3.default)(this.events()), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var e = _step9.value;\n\n          if (!t) {\n            t = e.timestamp().getTime();\n          } else {\n            if (e.timestamp() < t) {\n              result = false;\n            }\n\n            t = e.timestamp();\n          }\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * STATIC\n     */\n\n    /**\n      * Static function to compare two collections to each other. If the collections\n      * are of the same instance as each other then equals will return true.\n      *\n      * @param  {Collection} collection1\n      * @param  {Collection} collection2\n      *\n      * @return {bool} result\n      */\n\n  }], [{\n    key: \"equal\",\n    value: function equal(collection1, collection2) {\n      return collection1._type === collection2._type && collection1._eventList === collection2._eventList;\n    }\n    /**\n      * Static function to compare two collections to each other. If the collections\n      * are of the same value as each other then equals will return true.\n      *\n      * @param  {Collection} collection1\n      * @param  {Collection} collection2\n      *\n      * @return {bool} result\n      */\n\n  }, {\n    key: \"is\",\n    value: function is(collection1, collection2) {\n      return collection1._type === collection2._type && _immutable2.default.is(collection1._eventList, collection2._eventList);\n    }\n  }]);\n  return Collection;\n}(_bounded2.default);\n/*\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nexports.default = Collection;","map":null,"metadata":{},"sourceType":"script"}