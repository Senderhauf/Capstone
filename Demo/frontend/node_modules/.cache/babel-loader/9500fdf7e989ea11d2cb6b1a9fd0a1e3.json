{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _collection = require(\"./collection\");\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A Collector is used to accumulate events into multiple collections,\n * based on potentially many strategies. In this current implementation\n * a collection is partitioned based on the window that it falls in\n * and the group it is part of.\n *\n * Collections are emitted from this class to the supplied onTrigger\n * callback.\n */\n\n\nvar Collector = function () {\n  function Collector(options, onTrigger) {\n    (0, _classCallCheck3.default)(this, Collector);\n    var windowType = options.windowType,\n        windowDuration = options.windowDuration,\n        groupBy = options.groupBy,\n        emitOn = options.emitOn;\n    this._groupBy = groupBy;\n    this._emitOn = emitOn;\n    this._windowType = windowType;\n    this._windowDuration = windowDuration; // Callback for trigger\n\n    this._onTrigger = onTrigger; // Maintained collections\n\n    this._collections = {};\n  }\n\n  (0, _createClass3.default)(Collector, [{\n    key: \"flushCollections\",\n    value: function flushCollections() {\n      this.emitCollections(this._collections);\n    }\n  }, {\n    key: \"emitCollections\",\n    value: function emitCollections(collections) {\n      var _this = this;\n\n      if (this._onTrigger) {\n        _underscore2.default.each(collections, function (c) {\n          var collection = c.collection,\n              windowKey = c.windowKey,\n              groupByKey = c.groupByKey;\n          _this._onTrigger && _this._onTrigger(collection, windowKey, groupByKey);\n        });\n      }\n    }\n  }, {\n    key: \"addEvent\",\n    value: function addEvent(event) {\n      var _this2 = this;\n\n      var timestamp = event.timestamp(); //\n      // Window key\n      //\n\n      var windowType = this._windowType;\n      var windowKey = void 0;\n\n      if (windowType === \"fixed\") {\n        windowKey = _index2.default.getIndexString(this._windowDuration, timestamp);\n      } else if (windowType === \"daily\") {\n        windowKey = _index2.default.getDailyIndexString(timestamp);\n      } else if (windowType === \"monthly\") {\n        windowKey = _index2.default.getMonthlyIndexString(timestamp);\n      } else if (windowType === \"yearly\") {\n        windowKey = _index2.default.getYearlyIndexString(timestamp);\n      } else {\n        windowKey = windowType;\n      } //\n      // Groupby key\n      //\n\n\n      var groupByKey = this._groupBy(event); //\n      // Collection key\n      //\n\n\n      var collectionKey = groupByKey ? windowKey + \"::\" + groupByKey : windowKey;\n      var discard = false;\n\n      if (!_underscore2.default.has(this._collections, collectionKey)) {\n        this._collections[collectionKey] = {\n          windowKey: windowKey,\n          groupByKey: groupByKey,\n          collection: new _collection2.default()\n        };\n        discard = true;\n      }\n\n      this._collections[collectionKey].collection = this._collections[collectionKey].collection.addEvent(event); //\n      // If fixed windows, collect together old collections that\n      // will be discarded\n      //\n\n      var discards = {};\n\n      if (discard && windowType === \"fixed\") {\n        _underscore2.default.each(this._collections, function (c, k) {\n          if (windowKey !== c.windowKey) {\n            discards[k] = c;\n          }\n        });\n      } //\n      // Emit\n      //\n\n\n      var emitOn = this._emitOn;\n\n      if (emitOn === \"eachEvent\") {\n        this.emitCollections(this._collections);\n      } else if (emitOn === \"discard\") {\n        this.emitCollections(discards);\n\n        _underscore2.default.each((0, _keys2.default)(discards), function (k) {\n          delete _this2._collections[k];\n        });\n      } else if (emitOn === \"flush\") {// pass\n      } else {\n        throw new Error(\"Unknown emit type supplied to Collector\");\n      }\n    }\n  }]);\n  return Collector;\n}();\n/*\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nexports.default = Collector;","map":null,"metadata":{},"sourceType":"script"}