{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require(\"react-dom\");\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _pondjs = require(\"pondjs\");\n\nvar _util = require(\"../js/util\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n *  Copyright (c) 2015-present, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n// eslint-disable-line\n\n/**\n * Internal component which provides the top level event catcher for the charts.\n * This is a higher order component. It wraps a tree of SVG elements below it,\n * passed in as this.props.children, and catches events that they do not handle.\n *\n * The EventHandler is responsible for pan and zoom events as well as other click\n * and hover actions.\n */\n\n\nvar EventHandler = function (_React$Component) {\n  _inherits(EventHandler, _React$Component);\n\n  function EventHandler(props) {\n    _classCallCheck(this, EventHandler);\n\n    var _this = _possibleConstructorReturn(this, (EventHandler.__proto__ || Object.getPrototypeOf(EventHandler)).call(this, props));\n\n    _this.state = {\n      isPanning: false,\n      initialPanBegin: null,\n      initialPanEnd: null,\n      initialPanPosition: null\n    };\n    _this.handleScrollWheel = _this.handleScrollWheel.bind(_this);\n    _this.handleMouseDown = _this.handleMouseDown.bind(_this);\n    _this.handleMouseUp = _this.handleMouseUp.bind(_this);\n    _this.handleMouseOut = _this.handleMouseOut.bind(_this);\n    _this.handleMouseMove = _this.handleMouseMove.bind(_this);\n    return _this;\n  } // get the event mouse position relative to the event rect\n\n\n  _createClass(EventHandler, [{\n    key: \"getOffsetMousePosition\",\n    value: function getOffsetMousePosition(e) {\n      var offset = (0, _util.getElementOffset)(this.eventRect);\n      var x = e.pageX - offset.left;\n      var y = e.pageY - offset.top;\n      return [Math.round(x), Math.round(y)];\n    } //\n    // Event handlers\n    //\n\n  }, {\n    key: \"handleScrollWheel\",\n    value: function handleScrollWheel(e) {\n      if (!this.props.enablePanZoom && !this.props.enableDragZoom) {\n        return;\n      }\n\n      e.preventDefault();\n      var SCALE_FACTOR = 0.001;\n      var scale = 1 + e.deltaY * SCALE_FACTOR;\n\n      if (scale > 3) {\n        scale = 3;\n      }\n\n      if (scale < 0.1) {\n        scale = 0.1;\n      }\n\n      var xy = this.getOffsetMousePosition(e);\n      var begin = this.props.scale.domain()[0].getTime();\n      var end = this.props.scale.domain()[1].getTime();\n      var center = this.props.scale.invert(xy[0]).getTime();\n      var beginScaled = center - parseInt((center - begin) * scale, 10);\n      var endScaled = center + parseInt((end - center) * scale, 10); // Duration constraint\n\n      var duration = (end - begin) * scale;\n\n      if (this.props.minDuration) {\n        var minDuration = parseInt(this.props.minDuration, 10);\n\n        if (duration < this.props.minDuration) {\n          beginScaled = center - (center - begin) / (end - begin) * minDuration;\n          endScaled = center + (end - center) / (end - begin) * minDuration;\n        }\n      }\n\n      if (this.props.minTime && this.props.maxTime) {\n        var maxDuration = this.props.maxTime.getTime() - this.props.minTime.getTime();\n\n        if (duration > maxDuration) {\n          duration = maxDuration;\n        }\n      } // Range constraint\n\n\n      if (this.props.minTime && beginScaled < this.props.minTime.getTime()) {\n        beginScaled = this.props.minTime.getTime();\n        endScaled = beginScaled + duration;\n      }\n\n      if (this.props.maxTime && endScaled > this.props.maxTime.getTime()) {\n        endScaled = this.props.maxTime.getTime();\n        beginScaled = endScaled - duration;\n      }\n\n      var newBegin = new Date(beginScaled);\n      var newEnd = new Date(endScaled);\n      var newTimeRange = new _pondjs.TimeRange(newBegin, newEnd);\n\n      if (this.props.onZoom) {\n        this.props.onZoom(newTimeRange);\n      }\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(e) {\n      if (!this.props.enablePanZoom && !this.props.enableDragZoom) {\n        return;\n      }\n\n      e.preventDefault();\n      document.addEventListener(\"mouseover\", this.handleMouseMove);\n      document.addEventListener(\"mouseup\", this.handleMouseUp);\n\n      if (this.props.enableDragZoom) {\n        var offsetxy = this.getOffsetMousePosition(e);\n        this.setState({\n          isDragging: true,\n          initialDragZoom: offsetxy[0],\n          currentDragZoom: offsetxy[0]\n        });\n      }\n\n      if (this.props.enablePanZoom) {\n        var x = e.pageX;\n        var y = e.pageY;\n        var xy0 = [Math.round(x), Math.round(y)];\n        var begin = this.props.scale.domain()[0].getTime();\n        var end = this.props.scale.domain()[1].getTime();\n        this.setState({\n          isPanning: true,\n          initialPanBegin: begin,\n          initialPanEnd: end,\n          initialPanPosition: xy0\n        });\n      }\n\n      return false;\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(e) {\n      if (!this.props.onMouseClick && !this.props.enablePanZoom && !this.props.enableDragZoom) {\n        return;\n      }\n\n      e.stopPropagation();\n      document.removeEventListener(\"mouseover\", this.handleMouseMove);\n      document.removeEventListener(\"mouseup\", this.handleMouseUp);\n      var offsetxy = this.getOffsetMousePosition(e);\n      var x = e.pageX;\n      var isPanning = this.state.initialPanPosition && Math.abs(x - this.state.initialPanPosition[0]) > 2;\n      var isDragging = this.state.initialDragZoom && Math.abs(offsetxy[0] - this.state.initialDragZoom) > 2;\n\n      if (this.props.onMouseClick && !isPanning && !isDragging) {\n        this.props.onMouseClick(offsetxy[0], offsetxy[1]);\n      }\n\n      if (this.props.enableDragZoom) {\n        if (isDragging) {\n          var start = this.props.scale.invert(this.state.initialDragZoom).getTime();\n          var end = this.props.scale.invert(this.state.currentDragZoom).getTime();\n          var newBegin = parseInt(start, 10);\n          var newEnd = parseInt(end, 10);\n\n          if (this.props.minTime && newBegin < this.props.minTime.getTime()) {\n            newBegin = this.props.minTime.getTime();\n          }\n\n          if (this.props.maxTime && newEnd > this.props.maxTime.getTime()) {\n            newEnd = this.props.maxTime.getTime();\n          }\n\n          var newTimeRange = new _pondjs.TimeRange([newBegin, newEnd].sort());\n\n          if (this.props.onZoom) {\n            this.props.onZoom(newTimeRange);\n          }\n        }\n\n        this.setState({\n          isDragging: false,\n          initialDragZoom: null,\n          initialPanEnd: null,\n          currentDragZoom: null\n        });\n      }\n\n      if (this.props.enablePanZoom) {\n        this.setState({\n          isPanning: false,\n          initialPanBegin: null,\n          initialPanEnd: null,\n          initialPanPosition: null\n        });\n      }\n    }\n  }, {\n    key: \"handleMouseOut\",\n    value: function handleMouseOut(e) {\n      e.preventDefault();\n\n      if (this.props.onMouseOut) {\n        this.props.onMouseOut();\n      }\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(e) {\n      e.preventDefault();\n      var x = e.pageX;\n      var y = e.pageY;\n      var xy = [Math.round(x), Math.round(y)];\n      var offsetxy = this.getOffsetMousePosition(e);\n\n      if (this.state.isDragging) {\n        this.setState({\n          currentDragZoom: offsetxy[0]\n        });\n      }\n\n      if (this.state.isPanning) {\n        var xy0 = this.state.initialPanPosition;\n        var timeOffset = this.props.scale.invert(xy[0]).getTime() - this.props.scale.invert(xy0[0]).getTime();\n        var newBegin = parseInt(this.state.initialPanBegin - timeOffset, 10);\n        var newEnd = parseInt(this.state.initialPanEnd - timeOffset, 10);\n        var duration = parseInt(this.state.initialPanEnd - this.state.initialPanBegin, 10);\n\n        if (this.props.minTime && newBegin < this.props.minTime.getTime()) {\n          newBegin = this.props.minTime.getTime();\n          newEnd = newBegin + duration;\n        }\n\n        if (this.props.maxTime && newEnd > this.props.maxTime.getTime()) {\n          newEnd = this.props.maxTime.getTime();\n          newBegin = newEnd - duration;\n        }\n\n        var newTimeRange = new _pondjs.TimeRange(newBegin, newEnd);\n\n        if (this.props.onZoom) {\n          this.props.onZoom(newTimeRange);\n        }\n      } else if (this.props.onMouseMove) {\n        var mousePosition = this.getOffsetMousePosition(e);\n\n        if (this.props.onMouseMove) {\n          this.props.onMouseMove(mousePosition[0], mousePosition[1]);\n        }\n      }\n    } //\n    // Render\n    //\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var cursor = this.state.isPanning ? \"-webkit-grabbing\" : \"default\";\n      var handlers = {\n        onWheel: this.handleScrollWheel,\n        onMouseDown: this.handleMouseDown,\n        onMouseMove: this.handleMouseMove,\n        onMouseOut: this.handleMouseOut,\n        onMouseUp: this.handleMouseUp\n      };\n      return _react2.default.createElement(\"g\", _extends({\n        pointerEvents: \"all\"\n      }, handlers), _react2.default.createElement(\"rect\", {\n        key: \"handler-hit-rect\",\n        ref: function ref(c) {\n          _this2.eventRect = c;\n        },\n        style: {\n          fill: \"#000\",\n          opacity: 0.0,\n          cursor: cursor\n        },\n        x: 0,\n        y: 0,\n        width: this.props.width,\n        height: this.props.height\n      }), this.props.children, this.state.isDragging && _react2.default.createElement(\"rect\", {\n        style: {\n          opacity: 0.3,\n          fill: \"grey\"\n        },\n        x: Math.min(this.state.currentDragZoom, this.state.initialDragZoom),\n        y: 0,\n        width: Math.abs(this.state.currentDragZoom - this.state.initialDragZoom),\n        height: this.props.height\n      }));\n    }\n  }]);\n\n  return EventHandler;\n}(_react2.default.Component);\n\nexports.default = EventHandler;\nEventHandler.propTypes = {\n  children: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.node), _propTypes2.default.node]),\n  enablePanZoom: _propTypes2.default.bool,\n  enableDragZoom: _propTypes2.default.bool,\n  scale: _propTypes2.default.func.isRequired,\n  width: _propTypes2.default.number.isRequired,\n  height: _propTypes2.default.number.isRequired,\n  maxTime: _propTypes2.default.instanceOf(Date),\n  minTime: _propTypes2.default.instanceOf(Date),\n  minDuration: _propTypes2.default.number,\n  onZoom: _propTypes2.default.func,\n  onMouseMove: _propTypes2.default.func,\n  onMouseOut: _propTypes2.default.func,\n  onMouseClick: _propTypes2.default.func\n};\nEventHandler.defaultProps = {\n  enablePanZoom: false,\n  enableDragZoom: false\n};","map":null,"metadata":{},"sourceType":"script"}