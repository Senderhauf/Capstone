{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _immutable = require(\"immutable\");\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nvar _moment = require(\"moment\");\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\nA time range is a simple representation of a begin and end time, used\nto maintain consistency across an application.\n\n### Construction\n\nYou can define a TimeRange with moments, Javascript Date objects\nor ms since UNIX epoch. Here we construct one with two moments:\n\n```js\nvar fmt = \"YYYY-MM-DD HH:mm\";\nvar beginTime = moment(\"2012-01-11 11:11\", fmt);\nvar endTime =   moment(\"2012-02-22 12:12\", fmt);\nvar range = new TimeRange(beginTime, endTime);\n```\n\nor with ms times:\n\n```js\nvar range = new TimeRange([1326309060000, 1329941520000]);\n```\n\n */\n\n\nvar TimeRange = function () {\n  /**\n   * Builds a new TimeRange which may be of several different formats:\n   *   - Another TimeRange (copy constructor)\n   *   - An Immutable.List containing two Dates.\n   *   - A Javascript array containing two Date or ms timestamps\n   *   - Two arguments, begin and end, each of which may be a Data,\n   *     a Moment, or a ms timestamp.\n   */\n  function TimeRange(arg1, arg2) {\n    (0, _classCallCheck3.default)(this, TimeRange);\n\n    if (arg1 instanceof TimeRange) {\n      var other = arg1;\n      this._range = other._range;\n    } else if (arg1 instanceof _immutable2.default.List) {\n      var rangeList = arg1;\n      this._range = rangeList;\n    } else if (_underscore2.default.isArray(arg1)) {\n      var rangeArray = arg1;\n      this._range = new _immutable2.default.List([new Date(rangeArray[0]), new Date(rangeArray[1])]);\n    } else {\n      var b = arg1;\n      var e = arg2;\n\n      if (_underscore2.default.isDate(b) && _underscore2.default.isDate(e)) {\n        this._range = new _immutable2.default.List([new Date(b.getTime()), new Date(e.getTime())]);\n      } else if (_moment2.default.isMoment(b) && _moment2.default.isMoment(e)) {\n        this._range = new _immutable2.default.List([new Date(b.valueOf()), new Date(e.valueOf())]);\n      } else if (_underscore2.default.isNumber(b) && _underscore2.default.isNumber(e)) {\n        this._range = new _immutable2.default.List([new Date(b), new Date(e)]);\n      }\n    }\n  }\n  /**\n   * Returns the internal range, which is an Immutable List containing\n   * begin and end times.\n   *\n   * @return {Immutable.List} List containing the begin and end of the time range.\n   */\n\n\n  (0, _createClass3.default)(TimeRange, [{\n    key: \"range\",\n    value: function range() {\n      return this._range;\n    } //\n    // Serialize\n    //\n\n    /**\n     * Returns the TimeRange as JSON, which will be a Javascript array\n     * of two ms timestamps.\n     *\n     * @return {number[]} JSON representation of the TimeRange\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return [this.begin().getTime(), this.end().getTime()];\n    }\n    /**\n     * Returns the TimeRange as a string, useful for serialization.\n     *\n     * @return {string} String representation of the TimeRange\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return (0, _stringify2.default)(this.toJSON());\n    }\n    /**\n     * Returns the TimeRange as a string expressed in local time\n     *\n     * @return {string} String representation of the TimeRange\n     */\n\n  }, {\n    key: \"toLocalString\",\n    value: function toLocalString() {\n      return \"[\" + this.begin() + \", \" + this.end() + \"]\";\n    }\n    /**\n     * Returns the TimeRange as a string expressed in UTC time\n     *\n     * @return {string} String representation of the TimeRange\n     */\n\n  }, {\n    key: \"toUTCString\",\n    value: function toUTCString() {\n      return \"[\" + this.begin().toUTCString() + \", \" + this.end().toUTCString() + \"]\";\n    }\n    /**\n     * Returns a human friendly version of the TimeRange, e.g.\n     * \"Aug 1, 2014 05:19:59 am to Aug 1, 2014 07:41:06 am\"\n     *\n     * @return {string} Human friendly string representation of the TimeRange\n     */\n\n  }, {\n    key: \"humanize\",\n    value: function humanize() {\n      var begin = (0, _moment2.default)(this.begin());\n      var end = (0, _moment2.default)(this.end());\n      var beginStr = begin.format(\"MMM D, YYYY hh:mm:ss a\");\n      var endStr = end.format(\"MMM D, YYYY hh:mm:ss a\");\n      return beginStr + \" to \" + endStr;\n    }\n    /**\n     * Returns a human friendly version of the TimeRange\n     * @example\n     * \"a few seconds ago to a month ago\"\n     *\n     * @return {string} Human friendly string representation of the TimeRange\n     */\n\n  }, {\n    key: \"relativeString\",\n    value: function relativeString() {\n      var begin = (0, _moment2.default)(this.begin());\n      var end = (0, _moment2.default)(this.end());\n      return begin.fromNow() + \" to \" + end.fromNow();\n    }\n    /**\n     * Returns the begin time of the TimeRange.\n     *\n     * @return {Date} The begin time of the TimeRange\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      return this._range.get(0);\n    }\n    /**\n     * Returns the end time of the TimeRange.\n     *\n     * @return {Date} The end time of the TimeRange\n     */\n\n  }, {\n    key: \"end\",\n    value: function end() {\n      return this._range.get(1);\n    }\n    /**\n     * Sets a new begin time on the TimeRange. The result will be\n     * a new TimeRange.\n     *\n     * @param {Date} t Time to set the begin time to\n     * @return {TimeRange} The new mutated TimeRange\n     */\n\n  }, {\n    key: \"setBegin\",\n    value: function setBegin(t) {\n      return new TimeRange(this._range.set(0, t));\n    }\n    /**\n     * Sets a new end time on the TimeRange. The result will be\n     * a new TimeRange.\n     *\n     * @param {Date} t Time to set the end time to\n     * @return {TimeRange} The new mutated TimeRange\n     */\n\n  }, {\n    key: \"setEnd\",\n    value: function setEnd(t) {\n      return new TimeRange(this._range.set(1, t));\n    }\n    /**\n     * Returns if the two TimeRanges can be considered equal,\n     * in that they have the same times.\n     *\n     * @param {TimeRange} other The TimeRange to compare to\n     * @return {boolean} Result\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.begin().getTime() === other.begin().getTime() && this.end().getTime() === other.end().getTime();\n    }\n    /**\n     * Returns true if other is completely inside this.\n     *\n     * @param {TimeRange} other The TimeRange to compare to\n     * @return {boolean} Result\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(other) {\n      if (_underscore2.default.isDate(other)) {\n        return this.begin() <= other && this.end() >= other;\n      } else {\n        return this.begin() <= other.begin() && this.end() >= other.end();\n      }\n\n      return false;\n    }\n    /**\n     * Returns true if this TimeRange is completely within the supplied\n     * other TimeRange.\n     *\n     * @param {TimeRange} other The TimeRange to compare to\n     * @return {boolean} Result\n     */\n\n  }, {\n    key: \"within\",\n    value: function within(other) {\n      return this.begin() >= other.begin() && this.end() <= other.end();\n    }\n    /**\n     * Returns true if the passed in other TimeRange overlaps this time Range.\n     *\n     * @param {TimeRange} other The TimeRange to compare to\n     * @return {boolean} Result\n     */\n\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(other) {\n      if (this.contains(other.begin()) && !this.contains(other.end()) || this.contains(other.end()) && !this.contains(other.begin())) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Returns true if the passed in other Range in no way\n     * overlaps this time Range.\n     *\n     * @param {TimeRange} other The TimeRange to compare to\n     * @return {boolean} Result\n     */\n\n  }, {\n    key: \"disjoint\",\n    value: function disjoint(other) {\n      return this.end() < other.begin() || this.begin() > other.end();\n    }\n    /**\n     * @param {TimeRange} other The TimeRange to extend with\n     * @return {TimeRange} a new Timerange which covers the extents of this and\n     * other combined.\n     */\n\n  }, {\n    key: \"extents\",\n    value: function extents(other) {\n      var b = this.begin() < other.begin() ? this.begin() : other.begin();\n      var e = this.end() > other.end() ? this.end() : other.end();\n      return new TimeRange(new Date(b.getTime()), new Date(e.getTime()));\n    }\n    /**\n     * @param {TimeRange} other The TimeRange to intersect with\n     * @return {TimeRange} A new TimeRange which represents the intersection\n     * (overlapping) part of this and other.\n     */\n\n  }, {\n    key: \"intersection\",\n    value: function intersection(other) {\n      if (this.disjoint(other)) {\n        return undefined;\n      }\n\n      var b = this.begin() > other.begin() ? this.begin() : other.begin();\n      var e = this.end() < other.end() ? this.end() : other.end();\n      return new TimeRange(new Date(b.getTime()), new Date(e.getTime()));\n    }\n    /**\n     * @return {number} The duration of the TimeRange in milliseconds\n     */\n\n  }, {\n    key: \"duration\",\n    value: function duration() {\n      return this.end().getTime() - this.begin().getTime();\n    }\n    /**\n     * @return {string} A user friendly version of the duration.\n     */\n\n  }, {\n    key: \"humanizeDuration\",\n    value: function humanizeDuration() {\n      return _moment2.default.duration(this.duration()).humanize();\n    } //\n    // Static TimeRange creators\n    //\n\n    /**\n     * @return {TimeRange} The last day, as a TimeRange\n     */\n\n  }], [{\n    key: \"lastDay\",\n    value: function lastDay() {\n      var endTime = (0, _moment2.default)();\n      var beginTime = endTime.clone().subtract(24, \"hours\");\n      return new TimeRange(beginTime, endTime);\n    }\n    /**\n     * @return {TimeRange} The last seven days, as a TimeRange\n     */\n\n  }, {\n    key: \"lastSevenDays\",\n    value: function lastSevenDays() {\n      var endTime = (0, _moment2.default)();\n      var beginTime = endTime.clone().subtract(7, \"days\");\n      return new TimeRange(beginTime, endTime);\n    }\n    /**\n     * @return {TimeRange} The last thirty days, as a TimeRange\n     */\n\n  }, {\n    key: \"lastThirtyDays\",\n    value: function lastThirtyDays() {\n      var endTime = (0, _moment2.default)();\n      var beginTime = endTime.clone().subtract(30, \"days\");\n      return new TimeRange(beginTime, endTime);\n    }\n    /**\n     * @return {TimeRange} The last month, as a TimeRange\n     */\n\n  }, {\n    key: \"lastMonth\",\n    value: function lastMonth() {\n      var endTime = (0, _moment2.default)();\n      var beginTime = endTime.clone().subtract(1, \"month\");\n      return new TimeRange(beginTime, endTime);\n    }\n    /**\n     * @return {TimeRange} The last 90 days, as a TimeRange\n     */\n\n  }, {\n    key: \"lastNinetyDays\",\n    value: function lastNinetyDays() {\n      var endTime = (0, _moment2.default)();\n      var beginTime = endTime.clone().subtract(90, \"days\");\n      return new TimeRange(beginTime, endTime);\n    }\n    /**\n     * @return {TimeRange} The last year, as a TimeRange\n     */\n\n  }, {\n    key: \"lastYear\",\n    value: function lastYear() {\n      var endTime = (0, _moment2.default)();\n      var beginTime = endTime.clone().subtract(1, \"year\");\n      return new TimeRange(beginTime, endTime);\n    }\n  }]);\n  return TimeRange;\n}();\n/*\n *  Copyright (c) 2015-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nexports.default = TimeRange;","map":null,"metadata":{},"sourceType":"script"}