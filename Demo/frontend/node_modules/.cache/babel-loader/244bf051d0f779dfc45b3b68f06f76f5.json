{"ast":null,"code":"/*! Moment Duration Format v1.3.0\n *  https://github.com/jsmreese/moment-duration-format \n *  Date: 2014-07-15\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2014 John Madhavan-Reese\n *  Released under the MIT license\n */\n(function (root, undefined) {\n  // repeatZero(qty)\n  // returns \"0\" repeated qty times\n  function repeatZero(qty) {\n    var result = \"\"; // exit early\n    // if qty is 0 or a negative number\n    // or doesn't coerce to an integer\n\n    qty = parseInt(qty, 10);\n\n    if (!qty || qty < 1) {\n      return result;\n    }\n\n    while (qty) {\n      result += \"0\";\n      qty -= 1;\n    }\n\n    return result;\n  } // padZero(str, len [, isRight])\n  // pads a string with zeros up to a specified length\n  // will not pad a string if its length is aready\n  // greater than or equal to the specified length\n  // default output pads with zeros on the left\n  // set isRight to `true` to pad with zeros on the right\n\n\n  function padZero(str, len, isRight) {\n    if (str == null) {\n      str = \"\";\n    }\n\n    str = \"\" + str;\n    return (isRight ? str : \"\") + repeatZero(len - str.length) + (isRight ? \"\" : str);\n  } // isArray\n\n\n  function isArray(array) {\n    return Object.prototype.toString.call(array) === \"[object Array]\";\n  } // isObject\n\n\n  function isObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  } // findLast\n\n\n  function findLast(array, callback) {\n    var index = array.length;\n\n    while (index -= 1) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n    }\n  } // find\n\n\n  function find(array, callback) {\n    var index = 0,\n        max = array.length,\n        match;\n\n    if (typeof callback !== \"function\") {\n      match = callback;\n\n      callback = function callback(item) {\n        return item === match;\n      };\n    }\n\n    while (index < max) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n\n      index += 1;\n    }\n  } // each\n\n\n  function each(array, callback) {\n    var index = 0,\n        max = array.length;\n\n    if (!array || !max) {\n      return;\n    }\n\n    while (index < max) {\n      if (callback(array[index], index) === false) {\n        return;\n      }\n\n      index += 1;\n    }\n  } // map\n\n\n  function map(array, callback) {\n    var index = 0,\n        max = array.length,\n        ret = [];\n\n    if (!array || !max) {\n      return ret;\n    }\n\n    while (index < max) {\n      ret[index] = callback(array[index], index);\n      index += 1;\n    }\n\n    return ret;\n  } // pluck\n\n\n  function pluck(array, prop) {\n    return map(array, function (item) {\n      return item[prop];\n    });\n  } // compact\n\n\n  function compact(array) {\n    var ret = [];\n    each(array, function (item) {\n      if (item) {\n        ret.push(item);\n      }\n    });\n    return ret;\n  } // unique\n\n\n  function unique(array) {\n    var ret = [];\n    each(array, function (_a) {\n      if (!find(ret, _a)) {\n        ret.push(_a);\n      }\n    });\n    return ret;\n  } // intersection\n\n\n  function intersection(a, b) {\n    var ret = [];\n    each(a, function (_a) {\n      each(b, function (_b) {\n        if (_a === _b) {\n          ret.push(_a);\n        }\n      });\n    });\n    return unique(ret);\n  } // rest\n\n\n  function rest(array, callback) {\n    var ret = [];\n    each(array, function (item, index) {\n      if (!callback(item)) {\n        ret = array.slice(index);\n        return false;\n      }\n    });\n    return ret;\n  } // initial\n\n\n  function initial(array, callback) {\n    var reversed = array.slice().reverse();\n    return rest(reversed, callback).reverse();\n  } // extend\n\n\n  function extend(a, b) {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n\n    return a;\n  } // define internal moment reference\n\n\n  var moment;\n\n  if (typeof require === \"function\") {\n    try {\n      moment = require('moment');\n    } catch (e) {}\n  }\n\n  if (!moment && root.moment) {\n    moment = root.moment;\n  }\n\n  if (!moment) {\n    throw \"Moment Duration Format cannot find Moment.js\";\n  } // moment.duration.format([template] [, precision] [, settings])\n\n\n  moment.duration.fn.format = function () {\n    var tokenizer,\n        tokens,\n        types,\n        typeMap,\n        momentTypes,\n        foundFirst,\n        trimIndex,\n        args = [].slice.call(arguments),\n        settings = extend({}, this.format.defaults),\n        // keep a shadow copy of this moment for calculating remainders\n    remainder = moment.duration(this); // add a reference to this duration object to the settings for use\n    // in a template function\n\n    settings.duration = this; // parse arguments\n\n    each(args, function (arg) {\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    }); // types\n\n    types = settings.types = isArray(settings.types) ? settings.types : settings.types.split(\" \"); // template\n\n    if (typeof settings.template === \"function\") {\n      settings.template = settings.template.apply(settings);\n    } // tokenizer regexp\n\n\n    tokenizer = new RegExp(map(types, function (type) {\n      return settings[type].source;\n    }).join(\"|\"), \"g\"); // token type map function\n\n    typeMap = function typeMap(token) {\n      return find(types, function (type) {\n        return settings[type].test(token);\n      });\n    }; // tokens array\n\n\n    tokens = map(settings.template.match(tokenizer), function (token, index) {\n      var type = typeMap(token),\n          length = token.length;\n      return {\n        index: index,\n        length: length,\n        // replace escaped tokens with the non-escaped token text\n        token: type === \"escape\" ? token.replace(settings.escape, \"$1\") : token,\n        // ignore type on non-moment tokens\n        type: type === \"escape\" || type === \"general\" ? null : type // calculate base value for all moment tokens\n        //baseValue: ((type === \"escape\" || type === \"general\") ? null : this.as(type))\n\n      };\n    }, this); // unique moment token types in the template (in order of descending magnitude)\n\n    momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\")))); // exit early if there are no momentTypes\n\n    if (!momentTypes.length) {\n      return pluck(tokens, \"token\").join(\"\");\n    } // calculate values for each token type in the template\n\n\n    each(momentTypes, function (momentType, index) {\n      var value, wholeValue, decimalValue, isLeast, isMost; // calculate integer and decimal value portions\n\n      value = remainder.as(momentType);\n      wholeValue = value > 0 ? Math.floor(value) : Math.ceil(value);\n      decimalValue = value - wholeValue; // is this the least-significant moment token found?\n\n      isLeast = index + 1 === momentTypes.length; // is this the most-significant moment token found?\n\n      isMost = !index; // update tokens array\n      // using this algorithm to not assume anything about\n      // the order or frequency of any tokens\n\n      each(tokens, function (token) {\n        if (token.type === momentType) {\n          extend(token, {\n            value: value,\n            wholeValue: wholeValue,\n            decimalValue: decimalValue,\n            isLeast: isLeast,\n            isMost: isMost\n          });\n\n          if (isMost) {\n            // note the length of the most-significant moment token:\n            // if it is greater than one and forceLength is not set, default forceLength to `true`\n            if (settings.forceLength == null && token.length > 1) {\n              settings.forceLength = true;\n            } // rationale is this:\n            // if the template is \"h:mm:ss\" and the moment value is 5 minutes, the user-friendly output is \"5:00\", not \"05:00\"\n            // shouldn't pad the `minutes` token even though it has length of two\n            // if the template is \"hh:mm:ss\", the user clearly wanted everything padded so we should output \"05:00\"\n            // if the user wanted the full padded output, they can set `{ trim: false }` to get \"00:05:00\"\n\n          }\n        }\n      }); // update remainder\n\n      remainder.subtract(wholeValue, momentType);\n    }); // trim tokens array\n\n    if (settings.trim) {\n      tokens = (settings.trim === \"left\" ? rest : initial)(tokens, function (token) {\n        // return `true` if:\n        // the token is not the least moment token (don't trim the least moment token)\n        // the token is a moment token that does not have a value (don't trim moment tokens that have a whole value)\n        return !(token.isLeast || token.type != null && token.wholeValue);\n      });\n    } // build output\n    // the first moment token can have special handling\n\n\n    foundFirst = false; // run the map in reverse order if trimming from the right\n\n    if (settings.trim === \"right\") {\n      tokens.reverse();\n    }\n\n    tokens = map(tokens, function (token) {\n      var val, decVal;\n\n      if (!token.type) {\n        // if it is not a moment token, use the token as its own value\n        return token.token;\n      } // apply negative precision formatting to the least-significant moment token\n\n\n      if (token.isLeast && settings.precision < 0) {\n        val = (Math.floor(token.wholeValue * Math.pow(10, settings.precision)) * Math.pow(10, -settings.precision)).toString();\n      } else {\n        val = token.wholeValue.toString();\n      } // remove negative sign from the beginning\n\n\n      val = val.replace(/^\\-/, \"\"); // apply token length formatting\n      // special handling for the first moment token that is not the most significant in a trimmed template\n\n      if (token.length > 1 && (foundFirst || token.isMost || settings.forceLength)) {\n        val = padZero(val, token.length);\n      } // add decimal value if precision > 0\n\n\n      if (token.isLeast && settings.precision > 0) {\n        decVal = token.decimalValue.toString().replace(/^\\-/, \"\").split(/\\.|e\\-/);\n\n        switch (decVal.length) {\n          case 1:\n            val += \".\" + padZero(decVal[0], settings.precision, true).slice(0, settings.precision);\n            break;\n\n          case 2:\n            val += \".\" + padZero(decVal[1], settings.precision, true).slice(0, settings.precision);\n            break;\n\n          case 3:\n            val += \".\" + padZero(repeatZero(+decVal[2] - 1) + (decVal[0] || \"0\") + decVal[1], settings.precision, true).slice(0, settings.precision);\n            break;\n\n          default:\n            throw \"Moment Duration Format: unable to parse token decimal value.\";\n        }\n      } // add a negative sign if the value is negative and token is most significant\n\n\n      if (token.isMost && token.value < 0) {\n        val = \"-\" + val;\n      }\n\n      foundFirst = true;\n      return val;\n    }); // undo the reverse if trimming from the right\n\n    if (settings.trim === \"right\") {\n      tokens.reverse();\n    }\n\n    return tokens.join(\"\");\n  };\n\n  moment.duration.fn.format.defaults = {\n    // token definitions\n    escape: /\\[(.+?)\\]/,\n    years: /[Yy]+/,\n    months: /M+/,\n    weeks: /[Ww]+/,\n    days: /[Dd]+/,\n    hours: /[Hh]+/,\n    minutes: /m+/,\n    seconds: /s+/,\n    milliseconds: /S+/,\n    general: /.+?/,\n    // token type names\n    // in order of descending magnitude\n    // can be a space-separated token name list or an array of token names\n    types: \"escape years months weeks days hours minutes seconds milliseconds general\",\n    // format options\n    // trim\n    // \"left\" - template tokens are trimmed from the left until the first moment token that has a value >= 1\n    // \"right\" - template tokens are trimmed from the right until the first moment token that has a value >= 1\n    // (the final moment token is not trimmed, regardless of value)\n    // `false` - template tokens are not trimmed\n    trim: \"left\",\n    // precision\n    // number of decimal digits to include after (to the right of) the decimal point (positive integer)\n    // or the number of digits to truncate to 0 before (to the left of) the decimal point (negative integer)\n    precision: 0,\n    // force first moment token with a value to render at full length even when template is trimmed and first moment token has length of 1\n    forceLength: null,\n    // template used to format duration\n    // may be a function or a string\n    // template functions are executed with the `this` binding of the settings object\n    // so that template strings may be dynamically generated based on the duration object\n    // (accessible via `this.duration`)\n    // or any of the other settings\n    template: function template() {\n      var types = this.types,\n          dur = this.duration,\n          lastType = findLast(types, function (type) {\n        return dur._data[type];\n      }); // default template strings for each duration dimension type\n\n      switch (lastType) {\n        case \"seconds\":\n          return \"h:mm:ss\";\n\n        case \"minutes\":\n          return \"d[d] h:mm\";\n\n        case \"hours\":\n          return \"d[d] h[h]\";\n\n        case \"days\":\n          return \"M[m] d[d]\";\n\n        case \"weeks\":\n          return \"y[y] w[w]\";\n\n        case \"months\":\n          return \"y[y] M[m]\";\n\n        case \"years\":\n          return \"y[y]\";\n\n        default:\n          return \"y[y] M[m] d[d] h:mm:ss\";\n      }\n    }\n  };\n})(this);","map":null,"metadata":{},"sourceType":"script"}