{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _d3Ease = require(\"d3-ease\");\n\nvar _d3Scale = require(\"d3-scale\");\n\nvar _reactHotLoader = require(\"react-hot-loader\");\n\nvar _Brush = require(\"./Brush\");\n\nvar _Brush2 = _interopRequireDefault(_Brush);\n\nvar _YAxis = require(\"./YAxis\");\n\nvar _YAxis2 = _interopRequireDefault(_YAxis);\n\nvar _Charts = require(\"./Charts\");\n\nvar _Charts2 = _interopRequireDefault(_Charts);\n\nvar _MultiBrush = require(\"./MultiBrush\");\n\nvar _MultiBrush2 = _interopRequireDefault(_MultiBrush);\n\nvar _TimeMarker = require(\"./TimeMarker\");\n\nvar _TimeMarker2 = _interopRequireDefault(_TimeMarker);\n\nvar _interpolators = require(\"../js/interpolators\");\n\nvar _interpolators2 = _interopRequireDefault(_interpolators);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n *  Copyright (c) 2015-present, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar AXIS_MARGIN = 5;\n\nfunction createScale(yaxis, type, min, max, y0, y1) {\n  var scale = void 0;\n\n  if (_underscore2.default.isUndefined(min) || _underscore2.default.isUndefined(max)) {\n    scale = null;\n  } else if (type === \"linear\") {\n    scale = (0, _d3Scale.scaleLinear)().domain([min, max]).range([y0, y1]).nice();\n  } else if (type === \"log\") {\n    var base = yaxis.props.logBase || 10;\n    scale = (0, _d3Scale.scaleLog)().base(base).domain([min, max]).range([y0, y1]);\n  } else if (type === \"power\") {\n    var power = yaxis.props.powerExponent || 2;\n    scale = (0, _d3Scale.scalePow)().exponent(power).domain([min, max]).range([y0, y1]);\n  }\n\n  return scale;\n}\n/**\n * A ChartRow is a container for a set of YAxis and multiple charts\n * which are overlaid on each other in a central canvas.\n *\n * Here is an example where a single `<ChartRow>` is defined within\n * the `<ChartContainer>`. Of course you can have any number of rows.\n *\n * For this row we specify the one prop `height` as 200 pixels high.\n *\n * Within the `<ChartRow>` we add:\n *\n * * `<YAxis>` elements for axes to the left of the chart\n * * `<Chart>` block containing our central chart area\n * * `<YAxis>` elements for our axes to the right of the charts\n *\n * ```\n * <ChartContainer timeRange={audSeries.timerange()}>\n *     <ChartRow height=\"200\">\n *         <YAxis />\n *         <YAxis />\n *         <Charts>\n *             charts...\n *        </Charts>\n *         <YAxis />\n *     </ChartRow>\n * </ChartContainer>\n * ```\n */\n\n\nvar ChartRow = function (_React$Component) {\n  _inherits(ChartRow, _React$Component);\n\n  function ChartRow(props) {\n    _classCallCheck(this, ChartRow); // id of clipping rectangle we will generate and use for each child\n    // chart. Lives in state to ensure just one clipping rectangle and\n    // id per chart row instance; we don't want a fresh id generated on\n    // each render.\n\n\n    var _this = _possibleConstructorReturn(this, (ChartRow.__proto__ || Object.getPrototypeOf(ChartRow)).call(this, props));\n\n    _this.isChildYAxis = function (child) {\n      return (0, _reactHotLoader.areComponentsEqual)(child.type, _YAxis2.default) || _underscore2.default.has(child.props, \"min\") && _underscore2.default.has(child.props, \"max\");\n    };\n\n    var clipId = _underscore2.default.uniqueId(\"clip_\");\n\n    var clipPathURL = \"url(#\" + clipId + \")\";\n    _this.state = {\n      clipId: clipId,\n      clipPathURL: clipPathURL\n    };\n    return _this;\n  }\n\n  _createClass(ChartRow, [{\n    key: \"updateScales\",\n    value: function updateScales(props) {\n      var _this2 = this;\n\n      var innerHeight = +props.height - AXIS_MARGIN * 2;\n      var rangeTop = AXIS_MARGIN;\n      var rangeBottom = innerHeight - AXIS_MARGIN;\n\n      _react2.default.Children.forEach(props.children, function (child) {\n        if (child === null) return;\n\n        if (_this2.isChildYAxis(child)) {\n          var _child$props = child.props,\n              id = _child$props.id,\n              max = _child$props.max,\n              min = _child$props.min,\n              _child$props$transiti = _child$props.transition,\n              transition = _child$props$transiti === undefined ? 0 : _child$props$transiti,\n              _child$props$type = _child$props.type,\n              type = _child$props$type === undefined ? \"linear\" : _child$props$type;\n\n          if (!_underscore2.default.has(_this2.scaleMap, id)) {\n            // If necessary, initialize a ScaleInterpolator for this y-axis.\n            // When the yScale changes, we will update this interpolator.\n            _this2.scaleMap[id] = new _interpolators2.default(transition, _d3Ease.easeSinOut, function (s) {\n              var yAxisScalerMap = _this2.state.yAxisScalerMap;\n              yAxisScalerMap[id] = s;\n\n              _this2.setState(yAxisScalerMap);\n            });\n          } // Get the vertical scale for this y-axis.\n\n\n          var scale = void 0;\n\n          if (_underscore2.default.has(child.props, \"yScale\")) {\n            // If the yScale prop is passed explicitly, use that.\n            scale = child.props.yScale;\n          } else {\n            // Otherwise, compute the scale based on the max and min props.\n            scale = createScale(child, type, min, max, rangeBottom, rangeTop);\n          } // Update the scale on the interpolator for this y-axis.\n\n\n          var cacheKey = type + \"-\" + min + \"-\" + max + \"-\" + rangeBottom + \"-\" + rangeTop;\n\n          _this2.scaleMap[id].setScale(cacheKey, scale);\n        }\n      }); // Update the state with the newly interpolated scaler for each y-axis.\n\n\n      var scalerMap = {};\n\n      _underscore2.default.forEach(this.scaleMap, function (interpolator, id) {\n        scalerMap[id] = interpolator.scaler();\n      });\n\n      this.setState({\n        yAxisScalerMap: scalerMap\n      });\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      // Our chart scales are driven off a mapping between id of the axis\n      // and the scale that axis represents. Depending on the transition time,\n      // this scale will animate over time. The controller of this animation is\n      // the ScaleInterpolator. We create new Scale Interpolators here for each\n      // axis id.\n      this.scaleMap = {};\n      this.updateScales(this.props);\n    }\n    /**\n     * When we get changes to the row's props we update our map of\n     * axis scales.\n     */\n\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.updateScales(nextProps);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _props = this.props,\n          paddingLeft = _props.paddingLeft,\n          paddingRight = _props.paddingRight;\n      var axes = []; // Contains all the yAxis elements used in the render\n\n      var chartList = []; // Contains all the Chart elements used in the render\n      // Dimensions\n\n      var innerHeight = +this.props.height - AXIS_MARGIN * 2; //\n      // Build a map of elements that occupy left or right slots next to the\n      // chart.\n      //\n      // If an element has both and id and a min/max range, then we consider\n      // it to be a y axis. For those we calculate a d3 scale that can be\n      // reference by a chart. That scale will also be available to the axis\n      // when it renders.\n      //\n      // For this row, we will need to know how many axis slots we are using.\n      //\n\n      var yAxisMap = {}; // Maps axis id -> axis element\n\n      var leftAxisList = []; // Ordered list of left axes ids\n\n      var rightAxisList = []; // Ordered list of right axes ids\n\n      var alignLeft = true;\n\n      _react2.default.Children.forEach(this.props.children, function (child) {\n        if (child === null) return;\n\n        if ((0, _reactHotLoader.areComponentsEqual)(child.type, _Charts2.default)) {\n          alignLeft = false;\n        } else {\n          var _id = child.props.id; // Check to see if we think this 'axis' is actually an axis\n\n          if (_this3.isChildYAxis(child)) {\n            var yaxis = child;\n\n            if (yaxis.props.id && yaxis.props.visible !== false) {\n              // Relate id to the axis\n              yAxisMap[yaxis.props.id] = yaxis;\n            } // Columns counts\n\n\n            if (alignLeft) {\n              leftAxisList.push(_id);\n            } else {\n              rightAxisList.push(_id);\n            }\n          }\n        }\n      }); // Since we'll be building the left axis items from the inside to the outside\n\n\n      leftAxisList.reverse(); //\n      // Push each axis onto the axes, transforming each into its\n      // column location\n      //\n\n      var transform = void 0;\n      var id = void 0;\n      var props = void 0;\n      var axis = void 0;\n      var posx = 0; // Space used by columns on left and right of charts\n\n      var leftWidth = _underscore2.default.reduce(this.props.leftAxisWidths, function (a, b) {\n        return a + b;\n      }, 0);\n\n      var rightWidth = _underscore2.default.reduce(this.props.rightAxisWidths, function (a, b) {\n        return a + b;\n      }, 0);\n\n      var chartWidth = this.props.width - leftWidth - rightWidth - paddingLeft - paddingRight;\n      posx = leftWidth;\n\n      for (var leftColumnIndex = 0; leftColumnIndex < this.props.leftAxisWidths.length; leftColumnIndex += 1) {\n        var colWidth = this.props.leftAxisWidths[leftColumnIndex];\n        posx -= colWidth;\n\n        if (colWidth > 0 && leftColumnIndex < leftAxisList.length) {\n          id = leftAxisList[leftColumnIndex];\n\n          if (_underscore2.default.has(yAxisMap, id)) {\n            transform = \"translate(\" + (posx + paddingLeft) + \",0)\"; // Additional props for left aligned axes\n\n            props = {\n              width: colWidth,\n              height: innerHeight,\n              chartExtent: chartWidth,\n              isInnerAxis: leftColumnIndex === 0,\n              align: \"left\",\n              scale: this.scaleMap[id].latestScale()\n            }; // Cloned left axis\n\n            axis = _react2.default.cloneElement(yAxisMap[id], props);\n            axes.push(_react2.default.createElement(\"g\", {\n              key: \"y-axis-left-\" + leftColumnIndex,\n              transform: transform\n            }, axis));\n          }\n        }\n      }\n\n      posx = this.props.width - rightWidth - paddingRight;\n\n      for (var rightColumnIndex = 0; rightColumnIndex < this.props.rightAxisWidths.length; rightColumnIndex += 1) {\n        var _colWidth = this.props.rightAxisWidths[rightColumnIndex];\n\n        if (_colWidth > 0 && rightColumnIndex < rightAxisList.length) {\n          id = rightAxisList[rightColumnIndex];\n\n          if (_underscore2.default.has(yAxisMap, id)) {\n            transform = \"translate(\" + (posx + paddingLeft) + \",0)\"; // Additional props for right aligned axes\n\n            props = {\n              width: _colWidth,\n              height: innerHeight,\n              chartExtent: chartWidth,\n              //showGrid: this.props.showGrid,\n              isInnerAxis: rightColumnIndex === 0,\n              align: \"right\",\n              scale: this.scaleMap[id].latestScale()\n            }; // Cloned right axis\n\n            axis = _react2.default.cloneElement(yAxisMap[id], props);\n            axes.push(_react2.default.createElement(\"g\", {\n              key: \"y-axis-right-\" + rightColumnIndex,\n              transform: transform\n            }, axis));\n          }\n        }\n\n        posx += _colWidth;\n      } //\n      // Push each chart onto the chartList, transforming each to the right\n      // of the left axis slots and specifying its width. Each chart is passed\n      // its time and y-scale. The y-scale is looked up in scaleMap, whose\n      // current value is stored in the component state.\n      //\n\n\n      var chartTransform = \"translate(\" + (leftWidth + paddingLeft) + \",0)\";\n      var keyCount = 0;\n\n      _react2.default.Children.forEach(this.props.children, function (child) {\n        if (child === null) return;\n\n        if ((0, _reactHotLoader.areComponentsEqual)(child.type, _Charts2.default)) {\n          var _charts = child;\n\n          _react2.default.Children.forEach(_charts.props.children, function (chart) {\n            if (!_underscore2.default.has(chart.props, \"visible\") || chart.props.visible) {\n              var scale = null;\n\n              if (_underscore2.default.has(_this3.state.yAxisScalerMap, chart.props.axis)) {\n                scale = _this3.state.yAxisScalerMap[chart.props.axis];\n              }\n\n              var ytransition = null;\n\n              if (_underscore2.default.has(_this3.scaleMap, chart.props.axis)) {\n                ytransition = _this3.scaleMap[chart.props.axis];\n              }\n\n              var chartProps = {\n                key: keyCount,\n                width: chartWidth,\n                height: innerHeight,\n                timeScale: _this3.props.timeScale,\n                timeFormat: _this3.props.timeFormat\n              };\n\n              if (scale) {\n                chartProps.yScale = scale;\n              }\n\n              if (ytransition) {\n                chartProps.transition = ytransition;\n              }\n\n              chartList.push(_react2.default.cloneElement(chart, chartProps));\n              keyCount += 1;\n            }\n          });\n        }\n      }); //\n      // Push each child Brush on to the brush list.  We need brushed to be\n      // rendered last (on top) of everything else in the Z order, both for\n      // visual correctness and to ensure that the brush gets mouse events\n      // before anything underneath\n      //\n\n\n      var brushList = [];\n      var multiBrushList = [];\n      keyCount = 0;\n\n      _react2.default.Children.forEach(this.props.children, function (child) {\n        if (child === null) return;\n\n        if ((0, _reactHotLoader.areComponentsEqual)(child.type, _Brush2.default) || (0, _reactHotLoader.areComponentsEqual)(child.type, _MultiBrush2.default)) {\n          var brushProps = {\n            key: \"brush-\" + keyCount,\n            width: chartWidth,\n            height: innerHeight,\n            timeScale: _this3.props.timeScale\n          };\n\n          if ((0, _reactHotLoader.areComponentsEqual)(child.type, _Brush2.default)) {\n            brushList.push(_react2.default.cloneElement(child, brushProps));\n          } else {\n            multiBrushList.push(_react2.default.cloneElement(child, brushProps));\n          }\n        }\n\n        keyCount += 1;\n      });\n\n      var charts = _react2.default.createElement(\"g\", {\n        transform: chartTransform,\n        key: \"event-rect-group\"\n      }, _react2.default.createElement(\"g\", {\n        key: \"charts\",\n        clipPath: this.state.clipPathURL\n      }, chartList)); //\n      // Clipping\n      //\n\n\n      var clipper = _react2.default.createElement(\"defs\", null, _react2.default.createElement(\"clipPath\", {\n        id: this.state.clipId\n      }, _react2.default.createElement(\"rect\", {\n        x: \"0\",\n        y: \"0\",\n        style: {\n          strokeOpacity: 0.0\n        },\n        width: chartWidth,\n        height: innerHeight\n      }))); //\n      // Brush\n      //\n\n\n      var brushes = _react2.default.createElement(\"g\", {\n        transform: chartTransform,\n        key: \"brush-group\"\n      }, brushList); //\n      // Multi Brush\n      //\n\n\n      var multiBrushes = _react2.default.createElement(\"g\", {\n        transform: chartTransform,\n        key: \"multi-brush-group\"\n      }, multiBrushList); //\n      // TimeMarker used as a tracker\n      //\n\n\n      var tracker = void 0;\n\n      if (this.props.trackerTime) {\n        var timeFormat = this.props.trackerTimeFormat || this.props.timeFormat;\n        var timeMarkerProps = {\n          timeFormat: timeFormat,\n          showLine: false,\n          showTime: this.props.trackerShowTime,\n          time: this.props.trackerTime,\n          timeScale: this.props.timeScale,\n          width: chartWidth,\n          infoStyle: this.props.trackerStyle\n        };\n\n        if (this.props.trackerInfoValues) {\n          timeMarkerProps.infoWidth = this.props.trackerInfoWidth;\n          timeMarkerProps.infoHeight = this.props.trackerInfoHeight;\n          timeMarkerProps.infoValues = this.props.trackerInfoValues;\n          timeMarkerProps.timeFormat = this.props.trackerTimeFormat;\n        }\n\n        var trackerStyle = {\n          pointerEvents: \"none\"\n        };\n        var trackerTransform = \"translate(\" + (leftWidth + paddingLeft) + \",0)\";\n        tracker = _react2.default.createElement(\"g\", {\n          key: \"tracker-group\",\n          style: trackerStyle,\n          transform: trackerTransform\n        }, _react2.default.createElement(_TimeMarker2.default, timeMarkerProps));\n      }\n\n      return _react2.default.createElement(\"g\", null, clipper, axes, charts, brushes, multiBrushes, tracker);\n    }\n  }]);\n\n  return ChartRow;\n}(_react2.default.Component);\n\nexports.default = ChartRow;\nChartRow.defaultProps = {\n  trackerTimeFormat: \"%b %d %Y %X\",\n  enablePanZoom: false,\n  height: 100,\n  visible: true\n};\nChartRow.propTypes = {\n  /**\n   * The height of the row.\n   */\n  height: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),\n\n  /**\n   * Show or hide this row\n   */\n  visible: _propTypes2.default.bool,\n\n  /**\n   * Should the time be shown on top of the tracker info box\n   */\n  trackerShowTime: _propTypes2.default.bool,\n\n  /**\n   * The width of the tracker info box\n   */\n  trackerInfoWidth: _propTypes2.default.number,\n\n  /**\n   * The height of the tracker info box\n   */\n  trackerInfoHeight: _propTypes2.default.number,\n\n  /**\n   * Info box value or values to place next to the tracker line\n   * This is either an array of objects, with each object\n   * specifying the label (a string) and value (also a string)\n   * to be shown in the info box, or a simple string label.\n   */\n  trackerInfoValues: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    label: _propTypes2.default.string,\n    // eslint-disable-line\n    value: _propTypes2.default.string // eslint-disable-line\n\n  }))]),\n  children: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.node), _propTypes2.default.node]),\n  leftAxisWidths: _propTypes2.default.arrayOf(_propTypes2.default.number),\n  rightAxisWidths: _propTypes2.default.arrayOf(_propTypes2.default.number),\n  width: _propTypes2.default.number,\n  timeScale: _propTypes2.default.func,\n  trackerTimeFormat: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),\n  timeFormat: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),\n  trackerTime: _propTypes2.default.instanceOf(Date)\n};","map":null,"metadata":{},"sourceType":"script"}