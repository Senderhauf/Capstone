{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nrequire(\"d3-transition\");\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _merge = require(\"merge\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require(\"react-dom\");\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _d3Array = require(\"d3-array\");\n\nvar _d3Axis = require(\"d3-axis\");\n\nvar _d3Ease = require(\"d3-ease\");\n\nvar _d3Format = require(\"d3-format\");\n\nvar _d3Selection = require(\"d3-selection\");\n\nrequire(\"d3-selection-multi\");\n\nvar _util = require(\"../js/util\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n *  Copyright (c) 2015-present, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n// eslint-disable-line\n\n\nvar MARGIN = 0;\nvar defaultStyle = {\n  label: {\n    stroke: \"none\",\n    fill: \"#8B7E7E\",\n    // Default label color\n    fontWeight: 100,\n    fontSize: 12,\n    font: '\"Goudy Bookletter 1911\", sans-serif\"'\n  },\n  values: {\n    stroke: \"none\",\n    fill: \"#8B7E7E\",\n    // Default value color\n    fontWeight: 100,\n    fontSize: 11,\n    font: '\"Goudy Bookletter 1911\", sans-serif\"'\n  },\n  ticks: {\n    fill: \"none\",\n    stroke: \"#C0C0C0\"\n  },\n  axis: {\n    fill: \"none\",\n    stroke: \"#C0C0C0\"\n  }\n};\n/**\n * The `YAxis` widget displays a vertical axis to the left or right\n * of the charts. A `YAxis` always appears within a `ChartRow`, from\n * which it gets its height and positioning. You can have more than\n * one axis per row. You do control how wide it is.\n *\n * Here's a simple YAxis example:\n *\n * ```js\n * <YAxis\n *   id=\"price-axis\"\n *   label=\"Price (USD)\"\n *   min={0} max={100}\n *   width=\"60\"\n *   type=\"linear\"\n *   format=\"$,.2f\"\n * />\n * ```\n *\n * Visually you can control the axis `label`, its size via the `width`\n * prop, its `format`, and `type` of scale (linear). You can quicky turn\n * it on and off with the `visible` prop.\n *\n * Each axis also defines a scale through a `min` and `max` prop. Chart\n * then refer to the axis by by citing the axis `id` in their `axis`\n * prop. Those charts will then use the axis scale for their y-scale.\n * This is what ties them together. Many charts can use the same axis,\n * or not.\n *\n * Here is an example of two line charts that each have their own axis:\n *\n * ```js\n * <ChartContainer timeRange={audSeries.timerange()}>\n *     <ChartRow height=\"200\">\n *         <YAxis id=\"aud\" label=\"AUD\" min={0.5} max={1.5} width=\"60\" format=\"$,.2f\"/>\n *         <Charts>\n *             <LineChart axis=\"aud\" series={audSeries} style={audStyle}/>\n *             <LineChart axis=\"euro\" series={euroSeries} style={euroStyle}/>\n *         </Charts>\n *         <YAxis id=\"euro\" label=\"Euro\" min={0.5} max={1.5} width=\"80\" format=\"$,.2f\"/>\n *     </ChartRow>\n * </ChartContainer>\n * ```\n *\n *  Note that there are two `<YAxis>` components defined here, one before\n *  the `<Charts>` block and one after. This defines that the first axis will\n *  appear to the left of the charts and the second will appear right of the charts.\n *  Each of the line charts uses its `axis` prop to identify the axis (\"aud\" or \"euro\")\n *  it will use for its vertical scale.\n */\n\nvar YAxis = function (_React$Component) {\n  _inherits(YAxis, _React$Component);\n\n  function YAxis() {\n    _classCallCheck(this, YAxis);\n\n    return _possibleConstructorReturn(this, (YAxis.__proto__ || Object.getPrototypeOf(YAxis)).apply(this, arguments));\n  }\n\n  _createClass(YAxis, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.renderAxis(this.props.align, this.props.scale, +this.props.width, +this.props.height, this.props.showGrid, +this.props.chartExtent, this.props.hideAxisLine, this.props.absolute, this.props.type, this.props.format);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var scale = nextProps.scale,\n          align = nextProps.align,\n          width = nextProps.width,\n          height = nextProps.height,\n          chartExtent = nextProps.chartExtent,\n          absolute = nextProps.absolute,\n          format = nextProps.format,\n          type = nextProps.type,\n          showGrid = nextProps.showGrid,\n          hideAxisLine = nextProps.hideAxisLine;\n\n      if ((0, _util.scaleAsString)(this.props.scale) !== (0, _util.scaleAsString)(scale)) {\n        this.updateAxis(align, scale, width, height, showGrid, chartExtent, hideAxisLine, absolute, type, format);\n      } else if (this.props.format !== format || this.props.align !== align || this.props.width !== width || this.props.height !== height || this.props.type !== type || this.props.absolute !== absolute || this.props.chartExtent !== chartExtent || this.props.showGrid !== showGrid || this.props.hideAxisLine !== hideAxisLine) {\n        this.renderAxis(align, scale, +width, +height, showGrid, chartExtent, hideAxisLine, absolute, type, format);\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate() {\n      return false;\n    }\n  }, {\n    key: \"yformat\",\n    value: function yformat(fmt) {\n      if (_underscore2.default.isString(fmt)) {\n        return (0, _d3Format.format)(fmt);\n      } else if (_underscore2.default.isFunction(fmt)) {\n        return fmt;\n      } else {\n        return (0, _d3Format.format)(\"\");\n      }\n    }\n  }, {\n    key: \"mergeStyles\",\n    value: function mergeStyles(style) {\n      return {\n        labelStyle: (0, _merge2.default)(true, defaultStyle.label, this.props.style.label ? this.props.style.label : {}),\n        valueStyle: (0, _merge2.default)(true, defaultStyle.values, this.props.style.values ? this.props.style.values : {}),\n        axisStyle: (0, _merge2.default)(true, defaultStyle.axis, this.props.style.axis ? this.props.style.axis : {}),\n        tickStyle: (0, _merge2.default)(true, defaultStyle.ticks, this.props.style.ticks ? this.props.style.ticks : {})\n      };\n    }\n  }, {\n    key: \"postSelect\",\n    value: function postSelect(style, hideAxisLine, height) {\n      var valueStyle = style.valueStyle,\n          tickStyle = style.tickStyle,\n          axisStyle = style.axisStyle;\n      (0, _d3Selection.select)(_reactDom2.default.findDOMNode(this)).select(\"g\").selectAll(\".tick\").select(\"text\").styles(valueStyle);\n      (0, _d3Selection.select)(_reactDom2.default.findDOMNode(this)).select(\"g\").selectAll(\".tick\").select(\"line\").styles(tickStyle);\n      (0, _d3Selection.select)(_reactDom2.default.findDOMNode(this)).select(\"g\").selectAll(\".domain\").remove();\n\n      if (!hideAxisLine) {\n        (0, _d3Selection.select)(_reactDom2.default.findDOMNode(this)).select(\"g\").append(\"line\").styles(axisStyle).attr(\"x1\", 0).attr(\"y1\", 0).attr(\"x2\", 0).attr(\"y2\", height);\n      }\n    }\n  }, {\n    key: \"generator\",\n    value: function generator(type, absolute, yformat, axis, scale) {\n      var axisGenerator = void 0;\n\n      if (type === \"linear\" || type === \"power\") {\n        if (this.props.tickCount > 0) {\n          var stepSize = (this.props.max - this.props.min) / (this.props.tickCount - 1);\n          axisGenerator = axis(scale).tickValues((0, _d3Array.range)(this.props.min, this.props.max + this.props.max / 10000, stepSize)).tickFormat(function (d) {\n            if (absolute) {\n              return yformat(Math.abs(d));\n            }\n\n            return yformat(d);\n          }).tickSizeOuter(0);\n        } else {\n          if (this.props.height <= 200) {\n            axisGenerator = axis(scale).ticks(4).tickFormat(function (d) {\n              if (absolute) {\n                return yformat(Math.abs(d));\n              }\n\n              return yformat(d);\n            }).tickSizeOuter(0);\n          } else {\n            axisGenerator = axis(scale).tickFormat(function (d) {\n              if (absolute) {\n                return yformat(Math.abs(d));\n              }\n\n              return yformat(d);\n            }).tickSizeOuter(0);\n          }\n        }\n      } else if (type === \"log\") {\n        if (this.props.min === 0) {\n          throw Error(\"In a log scale, minimum value can't be 0\");\n        }\n\n        axisGenerator = axis(scale).ticks(10, \".2s\").tickSizeOuter(0);\n      }\n\n      return axisGenerator;\n    }\n  }, {\n    key: \"renderAxis\",\n    value: function renderAxis(align, scale, width, height, showGrid, chartExtent, hideAxisLine, absolute, type, fmt) {\n      var yformat = this.yformat(fmt);\n      var axis = align === \"left\" ? _d3Axis.axisLeft : _d3Axis.axisRight;\n      var style = this.mergeStyles(this.props.style);\n      var labelStyle = style.labelStyle,\n          valueStyle = style.valueStyle;\n      var tickSize = showGrid && this.props.isInnerAxis ? -chartExtent : 5;\n      var x = align === \"left\" ? width - MARGIN : 0;\n      var labelOffset = align === \"left\" ? this.props.labelOffset - 50 : 40 + this.props.labelOffset; // Axis generator\n\n      var axisGenerator = this.generator(type, absolute, yformat, axis, scale); // Remove the old axis from under this DOM node\n\n      (0, _d3Selection.select)(_reactDom2.default.findDOMNode(this)).selectAll(\"*\").remove(); // Add the new axis\n\n      this.axis = (0, _d3Selection.select)(_reactDom2.default.findDOMNode(this)).append(\"g\").attr(\"transform\", \"translate(\" + x + \",0)\").attr(\"class\", \"yaxis\").styles(valueStyle).call(axisGenerator.tickSize(tickSize)).append(\"text\").text(this.props.label).styles(labelStyle).attr(\"transform\", \"rotate(-90)\").attr(\"y\", labelOffset).attr(\"dy\", \".71em\").attr(\"text-anchor\", \"end\");\n      this.postSelect(style, hideAxisLine, height);\n    }\n  }, {\n    key: \"updateAxis\",\n    value: function updateAxis(align, scale, width, height, showGrid, chartExtent, hideAxisLine, absolute, type, fmt) {\n      var yformat = this.yformat(fmt);\n      var axis = align === \"left\" ? _d3Axis.axisLeft : _d3Axis.axisRight;\n      var style = this.mergeStyles(this.props.style);\n      var tickSize = showGrid && this.props.isInnerAxis ? -chartExtent : 5;\n      var axisGenerator = this.generator(type, absolute, yformat, axis, scale, tickSize); // Transition the existing axis\n\n      (0, _d3Selection.select)(_reactDom2.default.findDOMNode(this)).select(\".yaxis\").transition().duration(this.props.transition).ease(_d3Ease.easeSinOut).call(axisGenerator.tickSize(tickSize));\n      this.postSelect(style, hideAxisLine, height);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react2.default.createElement(\"g\", null);\n    }\n  }]);\n\n  return YAxis;\n}(_react2.default.Component);\n\nexports.default = YAxis;\nYAxis.defaultProps = {\n  id: \"yaxis\",\n  // id referred to by the chart\n  align: \"left\",\n  // left or right of the chart\n  min: 0,\n  // range\n  max: 1,\n  showGrid: false,\n  hideAxisLine: false,\n  type: \"linear\",\n  // linear, log, or power\n  absolute: false,\n  // Display scale always positive\n  format: \".2s\",\n  // Format string for d3.format\n  labelOffset: 0,\n  // Offset the label position\n  transition: 100,\n  // Axis transition time\n  width: 80,\n  style: defaultStyle\n};\nYAxis.propTypes = {\n  /**\n   * A name for the axis which can be used by a chart to reference the axis.\n   * This is used by the ChartRow to match charts to this axis.\n   */\n  id: _propTypes2.default.string.isRequired,\n  // eslint-disable-line\n\n  /**\n   * Show or hide this axis\n   */\n  visible: _propTypes2.default.bool,\n\n  /**\n   * The label to be displayed alongside the axis.\n   */\n  label: _propTypes2.default.string,\n\n  /**\n   * The scale type: linear, power, or log.\n   */\n  type: _propTypes2.default.oneOf([\"linear\", \"power\", \"log\"]),\n\n  /**\n   * Minimum value, which combined with \"max\", define the scale of the axis.\n   */\n  min: _propTypes2.default.number.isRequired,\n  // eslint-disable-line\n\n  /**\n   * Maximum value, which combined with \"min\", define the scale of the axis.\n   */\n  max: _propTypes2.default.number.isRequired,\n  // eslint-disable-line\n\n  /**\n   * A d3 scale for the y-axis which you can use to transform your data in the y direction.\n   * If omitted, the scale will be automatically computed based on the max and min props.\n   */\n  yScale: _propTypes2.default.func,\n\n  /**\n   * Render all ticks on the axis as positive values.\n   */\n  absolute: _propTypes2.default.bool,\n  // eslint-disable-line\n\n  /**\n   * Object specifying the CSS by which the axis can be styled. The object can contain:\n   * \"label\", \"values\", \"axis\" and \"ticks\". Each of these is an inline CSS style applied\n   * to the axis label, axis values, axis line and ticks respectively.\n   *\n   * Note that these are passed into d3's styling, so are regular CSS property names\n   * and not React's camel case names (e.g. \"stroke-dasharray\" not strokeDasharray).\n   */\n  style: _propTypes2.default.shape({\n    label: _propTypes2.default.object,\n    // eslint-disable-line\n    axis: _propTypes2.default.object,\n    // eslint-disable-line\n    values: _propTypes2.default.object,\n    // esline-disable-line\n    ticks: _propTypes2.default.object // esline-disable-line\n\n  }),\n\n  /**\n   * Render a horizontal grid by extending the axis ticks across the chart area. Note that this\n   * can only be applied to an inner axis (one next to a chart). If you have multiple axes then\n   * this can't be used on the outer axes. Also, if you have an axis on either side of the chart\n   * then you can use this, but the UX not be ideal.\n   */\n  showGrid: _propTypes2.default.bool,\n\n  /**\n   * Render the axis line. This is a nice option of you are also using `showGrid` as you may not\n   * want both the vertical axis line and the extended ticks.\n   */\n  hideAxisLine: _propTypes2.default.bool,\n\n  /**\n   * The transition time for moving from one scale to another\n   */\n  transition: _propTypes2.default.number,\n\n  /**\n   * The width of the axis\n   */\n  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),\n\n  /**\n   * Offset the axis label from its default position. This allows you to\n   * fine tune the label location, which may be necessary depending on the\n   * scale and how much room the tick labels take up. Maybe positive or\n   * negative.\n   */\n  labelOffset: _propTypes2.default.number,\n\n  /**\n   * If a string, the d3.format for the axis labels (e.g. `format=\\\"$,.2f\\\"`).\n   * If a function, that function will be called with each tick value and\n   * should generate a formatted string for that value to be used as the label\n   * for that tick (e.g. `function (n) { return Number(n).toFixed(2) }`).\n   */\n  format: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),\n\n  /**\n   * If the chart should be rendered to with the axis on the left or right.\n   * If you are using the axis in a ChartRow, you do not need to provide this.\n   */\n  align: _propTypes2.default.string,\n\n  /**\n   * [Internal] The scale supplied by the ChartRow\n   */\n  scale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The height supplied by the surrounding ChartContainer\n   */\n  height: _propTypes2.default.number,\n\n  /**\n   * The number of ticks\n   */\n  tickCount: _propTypes2.default.number\n};","map":null,"metadata":{},"sourceType":"script"}