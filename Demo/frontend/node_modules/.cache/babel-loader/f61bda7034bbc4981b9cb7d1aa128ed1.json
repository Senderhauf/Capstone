{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _merge = require(\"merge\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _pondjs = require(\"pondjs\");\n\nvar _util = require(\"../js/util\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n *  Copyright (c) 2016, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Renders a brush with the range defined in the prop `timeRange`.\n */\n\n\nvar Brush = function (_React$Component) {\n  _inherits(Brush, _React$Component);\n\n  function Brush(props) {\n    _classCallCheck(this, Brush);\n\n    var _this = _possibleConstructorReturn(this, (Brush.__proto__ || Object.getPrototypeOf(Brush)).call(this, props));\n\n    _this.state = {\n      isBrushing: false\n    };\n    _this.handleBrushMouseDown = _this.handleBrushMouseDown.bind(_this);\n    _this.handleOverlayMouseDown = _this.handleOverlayMouseDown.bind(_this);\n    _this.handleHandleMouseDown = _this.handleHandleMouseDown.bind(_this);\n    _this.handleMouseUp = _this.handleMouseUp.bind(_this);\n    _this.handleClick = _this.handleClick.bind(_this);\n    _this.handleMouseMove = _this.handleMouseMove.bind(_this);\n    return _this;\n  }\n\n  _createClass(Brush, [{\n    key: \"viewport\",\n    value: function viewport() {\n      var _props = this.props,\n          width = _props.width,\n          timeScale = _props.timeScale;\n      var viewBeginTime = timeScale.invert(0);\n      var viewEndTime = timeScale.invert(width);\n      return new _pondjs.TimeRange(viewBeginTime, viewEndTime);\n    } //\n    // Event handlers\n    //\n\n  }, {\n    key: \"handleBrushMouseDown\",\n    value: function handleBrushMouseDown(e) {\n      e.preventDefault();\n      var x = e.pageX,\n          y = e.pageY;\n      var xy0 = [Math.round(x), Math.round(y)];\n      var begin = +this.props.timeRange.begin();\n      var end = +this.props.timeRange.end();\n      document.addEventListener(\"mouseup\", this.handleMouseUp);\n      this.setState({\n        isBrushing: true,\n        brushingInitializationSite: \"brush\",\n        initialBrushBeginTime: begin,\n        initialBrushEndTime: end,\n        initialBrushXYPosition: xy0\n      });\n    }\n  }, {\n    key: \"handleOverlayMouseDown\",\n    value: function handleOverlayMouseDown(e) {\n      e.preventDefault();\n      var offset = (0, _util.getElementOffset)(this.overlay);\n      var x = e.pageX - offset.left;\n      var t = this.props.timeScale.invert(x).getTime();\n      document.addEventListener(\"mouseup\", this.handleMouseUp);\n      this.setState({\n        isBrushing: true,\n        brushingInitializationSite: \"overlay\",\n        initialBrushBeginTime: t,\n        initialBrushEndTime: t,\n        initialBrushXYPosition: null\n      });\n    }\n  }, {\n    key: \"handleHandleMouseDown\",\n    value: function handleHandleMouseDown(e, handle) {\n      e.preventDefault();\n      var x = e.pageX,\n          y = e.pageY;\n      var xy0 = [Math.round(x), Math.round(y)];\n      var begin = this.props.timeRange.begin().getTime();\n      var end = this.props.timeRange.end().getTime();\n      document.addEventListener(\"mouseover\", this.handleMouseMove);\n      document.addEventListener(\"mouseup\", this.handleMouseUp);\n      this.setState({\n        isBrushing: true,\n        brushingInitializationSite: \"handle-\" + handle,\n        initialBrushBeginTime: begin,\n        initialBrushEndTime: end,\n        initialBrushXYPosition: xy0\n      });\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(e) {\n      e.preventDefault();\n      document.removeEventListener(\"mouseover\", this.handleMouseMove);\n      document.removeEventListener(\"mouseup\", this.handleMouseUp);\n      this.setState({\n        isBrushing: false,\n        brushingInitializationSite: null,\n        initialBrushBeginTime: null,\n        initialBrushEndTime: null,\n        initialBrushXYPosition: null\n      });\n    }\n    /**\n     * Handles clearing the TimeRange if the user clicks on the overlay (but\n     * doesn't drag to create a new brush). This will send a null as the\n     * new TimeRange. The user of this code can react to that however they\n     * see fit, but the most logical response is to reset the timerange to\n     * some initial value. This behavior is optional.\n     */\n\n  }, {\n    key: \"handleClick\",\n    value: function handleClick() {\n      if (this.props.allowSelectionClear && this.props.onTimeRangeChanged) {\n        this.props.onTimeRangeChanged(null);\n      }\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(e) {\n      e.preventDefault();\n      var x = e.pageX;\n      var y = e.pageY;\n      var xy = [Math.round(x), Math.round(y)];\n      var viewport = this.viewport();\n\n      if (this.state.isBrushing) {\n        var newBegin = void 0;\n        var newEnd = void 0;\n        var tb = this.state.initialBrushBeginTime;\n        var te = this.state.initialBrushEndTime;\n\n        if (this.state.brushingInitializationSite === \"overlay\") {\n          var offset = (0, _util.getElementOffset)(this.overlay);\n          var xx = e.pageX - offset.left;\n          var t = this.props.timeScale.invert(xx).getTime();\n\n          if (t < tb) {\n            newBegin = t < viewport.begin().getTime() ? viewport.begin() : t;\n            newEnd = tb > viewport.end().getTime() ? viewport.end() : tb;\n          } else {\n            newBegin = tb < viewport.begin().getTime() ? viewport.begin() : tb;\n            newEnd = t > viewport.end().getTime() ? viewport.end() : t;\n          }\n        } else {\n          var xy0 = this.state.initialBrushXYPosition;\n          var timeOffset = this.props.timeScale.invert(xy0[0]).getTime() - this.props.timeScale.invert(xy[0]).getTime(); // Constrain\n\n          var startOffsetConstraint = timeOffset;\n          var endOffsetConstrain = timeOffset;\n\n          if (tb - timeOffset < viewport.begin()) {\n            startOffsetConstraint = tb - viewport.begin().getTime();\n          }\n\n          if (te - timeOffset > viewport.end()) {\n            endOffsetConstrain = te - viewport.end().getTime();\n          }\n\n          newBegin = this.state.brushingInitializationSite === \"brush\" || this.state.brushingInitializationSite === \"handle-left\" ? parseInt(tb - startOffsetConstraint, 10) : tb;\n          newEnd = this.state.brushingInitializationSite === \"brush\" || this.state.brushingInitializationSite === \"handle-right\" ? parseInt(te - endOffsetConstrain, 10) : te; // Swap if needed\n\n          if (newBegin > newEnd) {\n            var _ref = [newEnd, newBegin];\n            newBegin = _ref[0];\n            newEnd = _ref[1];\n          }\n        }\n\n        if (this.props.onTimeRangeChanged) {\n          this.props.onTimeRangeChanged(new _pondjs.TimeRange(newBegin, newEnd));\n        }\n      }\n    } //\n    // Render\n    //\n\n  }, {\n    key: \"renderOverlay\",\n    value: function renderOverlay() {\n      var _this2 = this;\n\n      var _props2 = this.props,\n          width = _props2.width,\n          height = _props2.height;\n      var cursor = void 0;\n\n      switch (this.state.brushingInitializationSite) {\n        case \"handle-right\":\n        case \"handle-left\":\n          cursor = \"ew-resize\";\n          break;\n\n        case \"brush\":\n          cursor = \"move\";\n          break;\n\n        default:\n          cursor = \"crosshair\";\n      }\n\n      var overlayStyle = {\n        fill: \"white\",\n        opacity: 0,\n        cursor: cursor\n      };\n      return _react2.default.createElement(\"rect\", {\n        ref: function ref(c) {\n          _this2.overlay = c;\n        },\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        style: overlayStyle,\n        onMouseDown: this.handleOverlayMouseDown,\n        onMouseUp: this.handleMouseUp,\n        onClick: this.handleClick\n      });\n    }\n  }, {\n    key: \"renderBrush\",\n    value: function renderBrush() {\n      var _props3 = this.props,\n          timeRange = _props3.timeRange,\n          timeScale = _props3.timeScale,\n          height = _props3.height,\n          style = _props3.style;\n\n      if (!timeRange) {\n        return _react2.default.createElement(\"g\", null);\n      }\n\n      var cursor = void 0;\n\n      switch (this.state.brushingInitializationSite) {\n        case \"handle-right\":\n        case \"handle-left\":\n          cursor = \"ew-resize\";\n          break;\n\n        case \"overlay\":\n          cursor = \"crosshair\";\n          break;\n\n        default:\n          cursor = \"move\";\n      } // Style of the brush area\n\n\n      var brushDefaultStyle = {\n        fill: \"#777\",\n        fillOpacity: 0.3,\n        stroke: \"#fff\",\n        shapeRendering: \"crispEdges\",\n        cursor: cursor\n      };\n      var brushStyle = (0, _merge2.default)(true, brushDefaultStyle, style);\n\n      if (!this.viewport().disjoint(timeRange)) {\n        var range = timeRange.intersection(this.viewport());\n        var begin = range.begin();\n        var end = range.end();\n        var _ref2 = [timeScale(begin), 0],\n            x = _ref2[0],\n            y = _ref2[1];\n        var endPos = timeScale(end);\n        var width = endPos - x;\n\n        if (width < 1) {\n          width = 1;\n        }\n\n        var bounds = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n        return _react2.default.createElement(\"rect\", _extends({}, bounds, {\n          style: brushStyle,\n          pointerEvents: \"all\",\n          onMouseDown: this.handleBrushMouseDown,\n          onMouseUp: this.handleMouseUp\n        }));\n      }\n\n      return _react2.default.createElement(\"g\", null);\n    }\n  }, {\n    key: \"renderHandles\",\n    value: function renderHandles() {\n      var _this3 = this;\n\n      var _props4 = this.props,\n          timeRange = _props4.timeRange,\n          timeScale = _props4.timeScale,\n          height = _props4.height;\n\n      if (!timeRange) {\n        return _react2.default.createElement(\"g\", null);\n      } // Style of the handles\n\n\n      var handleStyle = {\n        fill: \"white\",\n        opacity: 0,\n        cursor: \"ew-resize\"\n      };\n\n      if (!this.viewport().disjoint(timeRange)) {\n        var range = timeRange.intersection(this.viewport());\n\n        var _range$toJSON = range.toJSON(),\n            _range$toJSON2 = _slicedToArray(_range$toJSON, 2),\n            begin = _range$toJSON2[0],\n            end = _range$toJSON2[1];\n\n        var _ref3 = [timeScale(begin), 0],\n            x = _ref3[0],\n            y = _ref3[1];\n        var endPos = timeScale(end);\n        var width = endPos - x;\n\n        if (width < 1) {\n          width = 1;\n        }\n\n        var handleSize = this.props.handleSize;\n        var leftHandleBounds = {\n          x: x - 1,\n          y: y,\n          width: handleSize,\n          height: height\n        };\n        var rightHandleBounds = {\n          x: x + (width - handleSize),\n          y: y,\n          width: handleSize + 1,\n          height: height\n        };\n        return _react2.default.createElement(\"g\", null, _react2.default.createElement(\"rect\", _extends({}, leftHandleBounds, {\n          style: handleStyle,\n          pointerEvents: \"all\",\n          onMouseDown: function onMouseDown(e) {\n            return _this3.handleHandleMouseDown(e, \"left\");\n          },\n          onMouseUp: this.handleMouseUp\n        })), _react2.default.createElement(\"rect\", _extends({}, rightHandleBounds, {\n          style: handleStyle,\n          pointerEvents: \"all\",\n          onMouseDown: function onMouseDown(e) {\n            return _this3.handleHandleMouseDown(e, \"right\");\n          },\n          onMouseUp: this.handleMouseUp\n        })));\n      }\n\n      return _react2.default.createElement(\"g\", null);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react2.default.createElement(\"g\", {\n        onMouseMove: this.handleMouseMove\n      }, this.renderOverlay(), this.renderBrush(), this.renderHandles());\n    }\n  }]);\n\n  return Brush;\n}(_react2.default.Component);\n\nexports.default = Brush;\nBrush.propTypes = {\n  /**\n   * The timerange for the brush. Typically you would maintain this\n   * as state on the surrounding page, since it would likely control\n   * another page element, such as the range of the main chart. See\n   * also `onTimeRangeChanged()` for receiving notification of the\n   * brush range being changed by the user.\n   *\n   * Takes a Pond TimeRange object.\n   */\n  timeRange: _propTypes2.default.instanceOf(_pondjs.TimeRange),\n\n  /**\n   * The brush is rendered as an SVG rect. You can specify the style\n   * of this rect using this prop.\n   */\n  style: _propTypes2.default.object,\n  //eslint-disable-line\n\n  /**\n   * The size of the invisible side handles. Defaults to 6 pixels.\n   */\n  handleSize: _propTypes2.default.number,\n  allowSelectionClear: _propTypes2.default.bool,\n\n  /**\n   * A callback which will be called if the brush range is changed by\n   * the user. It is called with a Pond TimeRange object. Note that if\n   * `allowSelectionClear` is set to true, then this can also be called\n   * when the user performs a simple click outside the brush area. In\n   * this case it will be called with null as the TimeRange. You can\n   * use this to reset the selection, perhaps to some initial range.\n   */\n  onTimeRangeChanged: _propTypes2.default.func,\n\n  /**\n   * [Internal] The timeScale supplied by the surrounding ChartContainer\n   */\n  timeScale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The width supplied by the surrounding ChartContainer\n   */\n  width: _propTypes2.default.number,\n\n  /**\n   * [Internal] The height supplied by the surrounding ChartContainer\n   */\n  height: _propTypes2.default.number\n};\nBrush.defaultProps = {\n  handleSize: 6,\n  allowSelectionClear: false\n};","map":null,"metadata":{},"sourceType":"script"}