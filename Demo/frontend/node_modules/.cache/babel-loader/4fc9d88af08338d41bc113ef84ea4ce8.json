{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n *  Copyright (c) 2015-present, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _merge = require(\"merge\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _pondjs = require(\"pondjs\");\n\nvar _EventMarker = require(\"./EventMarker\");\n\nvar _EventMarker2 = _interopRequireDefault(_EventMarker);\n\nvar _styler = require(\"../js/styler\");\n\nvar _util = require(\"../js/util\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar defaultFillStyle = {\n  fill: \"steelblue\",\n  stroke: \"none\"\n};\nvar defaultMutedStyle = {\n  fill: \"grey\",\n  stroke: \"none\"\n};\nvar defaultStyle = [{\n  normal: _extends({}, defaultFillStyle, {\n    opacity: 0.2\n  }),\n  highlighted: _extends({}, defaultFillStyle, {\n    opacity: 0.3\n  }),\n  selected: _extends({}, defaultFillStyle, {\n    opacity: 0.3\n  }),\n  muted: _extends({}, defaultMutedStyle, {\n    opacity: 0.1\n  })\n}, {\n  normal: _extends({}, defaultFillStyle, {\n    opacity: 0.5\n  }),\n  highlighted: _extends({}, defaultFillStyle, {\n    opacity: 0.6\n  }),\n  selected: _extends({}, defaultFillStyle, {\n    opacity: 0.6\n  }),\n  muted: _extends({}, defaultMutedStyle, {\n    opacity: 0.2\n  })\n}, {\n  normal: _extends({}, defaultFillStyle, {\n    opacity: 0.9\n  }),\n  highlighted: _extends({}, defaultFillStyle, {\n    opacity: 1.0\n  }),\n  selected: _extends({}, defaultFillStyle, {\n    opacity: 1.0\n  }),\n  muted: _extends({}, defaultMutedStyle, {\n    opacity: 0.2\n  })\n}];\nvar defaultAggregation = {\n  size: \"5m\",\n  reducers: {\n    outer: [(0, _pondjs.min)(), (0, _pondjs.max)()],\n    inner: [(0, _pondjs.percentile)(25), (0, _pondjs.percentile)(75)],\n    center: (0, _pondjs.median)()\n  }\n};\n\nfunction getSeries(series, column) {\n  return series.map(function (e) {\n    var v = e.get(column);\n    var d = {};\n\n    switch (v.length) {\n      case 1:\n        d.center = v[0];\n        break;\n\n      case 2:\n        d.innerMin = v[0];\n        d.innerMax = v[1];\n        break;\n\n      case 3:\n        d.innerMin = v[0];\n        d.center = v[1];\n        d.innerMax = v[2];\n        break;\n\n      case 4:\n        d.outerMin = v[0];\n        d.innerMin = v[1];\n        d.innerMax = v[2];\n        d.outerMax = v[3];\n        break;\n\n      case 5:\n        d.outerMin = v[0];\n        d.innerMin = v[1];\n        d.center = v[2];\n        d.innerMax = v[3];\n        d.outerMax = v[4];\n        break;\n\n      default:\n        console.error(\"Tried to make boxchart from invalid array\");\n    }\n\n    var ee = new _pondjs.IndexedEvent(e.index(), d);\n    return ee;\n  });\n}\n\nfunction getAggregatedSeries(series, column) {\n  var aggregation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAggregation;\n  var size = aggregation.size,\n      reducers = aggregation.reducers;\n  var inner = reducers.inner,\n      outer = reducers.outer,\n      center = reducers.center;\n\n  function mapColumn(c, r) {\n    var obj = {};\n    obj[c] = r;\n    return obj;\n  }\n\n  var fixedWindowAggregation = {};\n\n  if (inner) {\n    fixedWindowAggregation.innerMin = mapColumn(column, inner[0]);\n    fixedWindowAggregation.innerMax = mapColumn(column, inner[1]);\n  }\n\n  if (outer) {\n    fixedWindowAggregation.outerMin = mapColumn(column, outer[0]);\n    fixedWindowAggregation.outerMax = mapColumn(column, outer[1]);\n  }\n\n  if (center) {\n    fixedWindowAggregation.center = mapColumn(column, center);\n  }\n\n  var aggregatedSeries = series.fixedWindowRollup({\n    windowSize: size,\n    aggregation: fixedWindowAggregation\n  });\n  return aggregatedSeries;\n}\n/**\n * Renders a boxplot chart.\n *\n * The TimeSeries supplied to the boxplot, as the `series` prop can be one of two types:\n *\n *  1) It can be a TimeSeries containing IndexedEvents or TimeRangeEvents.\n *     In this case a `column` prop should be supplied to specify the\n *     data column containing the dimensions of the boxes. This props\n *     should be an array of size 1 to 5 elements. e.g. [12, 18, 22, 28]. The\n *     numbers should be ordered, lowest to greatest.\n *\n *  2) A TimeSeries containing timestamp based Events. In this case the\n *     boxplot will be aggregated for you. To control the aggregation you can supply\n *     an `aggregation` prop: a structure to specify the window size and\n *     reducers used to determine the boxes.\n *\n * In both cases you are generating up to two ranges and a center marker. In the\n * first case you are defining this based on the array of numbers. The outer numbers\n * specify the outerRange, the inner numbers specify the innerRange and the middle\n * number specifies the center marker. In the second case you are building those ranges\n * from denser data, specifying a window and aggregation functions to build each\n * of the ranges and center maker.\n *\n * In both cases you do not need to supply all the values. For example if you\n * provide an array of 2 elements, that would define a single range, with no outer range\n * and no center marker. The BoxChart is pretty flexible in that way, so you\n * can use it in many situations.\n *\n * Here is an example of using it to display temperature ranges. The series\n * passed to this code would be a TimeSeries containing IndexedEvents. For\n * each event, the column `temp` contains an array of values used for the\n * box plot ranges:\n *\n * ```\n *     <BoxChart\n *       axis=\"temperatureAxis\"\n *       style={style}\n *       column=\"temp\"\n *       series={series} />\n * ```\n *\n * While here is an example with a dense TimeSeries of Events supplied,\n * along with an aggregation specification. This code would produce an\n * outer range from the 5th percentile to the 95th, along with an inner\n * range for the interquantile, and a center marker at the median:\n *\n * ```\n *    <BoxChart\n *      axis=\"speedaxis\"\n *      series={speed}\n *      column=\"speed\"\n *      style={style}\n *      aggregation={{\n *        size: this.state.rollup,\n *        reducers: {\n *          outer: [percentile(5), percentile(95)],\n *          inner: [percentile(25), percentile(75)],\n *          center: median(),\n *        },\n *      }}\n *    />\n * ```\n *\n * The BoxChart supports Info boxes, highlighting and selection.\n *\n * Note: selection and highlighting is on the whole event, not individual ranges.\n * Also note that since the box chart builds an internal TimeSeries for performance\n * reasons, selection will give you and IndexedEvent, but it won't be the same\n * IndexedEvent in your `series`. Similarly if you are using the aggregation\n * specification you will get events for the rollup, not your original data.\n */\n\n\nvar BoxChart = function (_React$Component) {\n  _inherits(BoxChart, _React$Component);\n\n  function BoxChart(props) {\n    _classCallCheck(this, BoxChart);\n\n    var _this = _possibleConstructorReturn(this, (BoxChart.__proto__ || Object.getPrototypeOf(BoxChart)).call(this, props));\n\n    if (props.series._collection._type === _pondjs.TimeEvent // eslint-disable-line\n    ) {\n        _this.series = getAggregatedSeries(props.series, props.column, props.aggregation);\n      } else {\n      _this.series = getSeries(props.series, props.column);\n    }\n\n    return _this;\n  }\n\n  _createClass(BoxChart, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var aggregation = nextProps.aggregation;\n      var aggregationChanged = false;\n\n      if (_underscore2.default.isUndefined(aggregation) !== _underscore2.default.isUndefined(this.props.aggregation)) {\n        aggregationChanged = true;\n      }\n\n      if (aggregation && this.props.aggregation) {\n        if (aggregation.size !== this.props.aggregation.size) {\n          aggregationChanged = true;\n        }\n      }\n\n      if (aggregationChanged) {\n        this.series = getAggregatedSeries(nextProps.series, nextProps.column, nextProps.aggregation);\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      var newSeries = nextProps.series;\n      var oldSeries = this.props.series;\n      var width = nextProps.width;\n      var timeScale = nextProps.timeScale;\n      var yScale = nextProps.yScale;\n      var column = nextProps.column;\n      var style = nextProps.style;\n      var aggregation = nextProps.aggregation;\n      var highlighted = nextProps.highlighted;\n      var selected = nextProps.selected;\n      var widthChanged = this.props.width !== width;\n      var timeScaleChanged = (0, _util.scaleAsString)(this.props.timeScale) !== (0, _util.scaleAsString)(timeScale);\n      var yAxisScaleChanged = this.props.yScale !== yScale;\n      var columnChanged = this.props.column !== column;\n      var styleChanged = JSON.stringify(this.props.style) !== JSON.stringify(style);\n      var highlightedChanged = this.props.highlighted !== highlighted;\n      var selectedChanged = this.props.selected !== selected;\n      var aggregationChanged = false;\n\n      if (_underscore2.default.isUndefined(aggregation) !== _underscore2.default.isUndefined(this.props.aggregation)) {\n        aggregationChanged = true;\n      }\n\n      if (aggregation && this.props.aggregation) {\n        if (aggregation.size !== this.props.aggregation.size) {\n          aggregationChanged = true;\n        }\n      }\n\n      var seriesChanged = false;\n\n      if (oldSeries.size() !== newSeries.size()) {\n        seriesChanged = true;\n      } else {\n        seriesChanged = !_pondjs.TimeSeries.is(oldSeries, newSeries);\n      } // If the series changes we need to rebuild this.series with\n      // the incoming props\n\n\n      if (seriesChanged) {\n        if (nextProps.series._collection._type === _pondjs.TimeEvent // eslint-disable-line\n        ) {\n            this.series = getAggregatedSeries(nextProps.series, nextProps.column, nextProps.aggregation);\n          } else {\n          this.series = getSeries(nextProps.series, nextProps.column);\n        }\n      }\n\n      return seriesChanged || timeScaleChanged || widthChanged || columnChanged || styleChanged || yAxisScaleChanged || aggregationChanged || highlightedChanged || selectedChanged;\n    }\n  }, {\n    key: \"handleHover\",\n    value: function handleHover(e, event) {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(event);\n      }\n    }\n  }, {\n    key: \"handleHoverLeave\",\n    value: function handleHoverLeave() {\n      if (this.props.onHighlightChange) {\n        this.props.onHighlightChange(null);\n      }\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e, event) {\n      if (this.props.onSelectionChange) {\n        this.props.onSelectionChange(event);\n      }\n\n      e.stopPropagation();\n    }\n  }, {\n    key: \"providedStyleArray\",\n    value: function providedStyleArray(column) {\n      var style = {};\n\n      if (this.props.style) {\n        if (this.props.style instanceof _styler.Styler) {\n          style = this.props.style.boxChartStyle()[column];\n        } else if (_underscore2.default.isFunction(this.props.style)) {\n          style = this.props.style(column);\n        } else if (_underscore2.default.isObject(this.props.style)) {\n          style = this.props.style ? this.props.style[column] : defaultStyle;\n        }\n      }\n\n      return style;\n    }\n    /**\n     * Returns the style used for drawing the path\n     */\n\n  }, {\n    key: \"style\",\n    value: function style(column, event, level) {\n      var style = void 0;\n\n      if (!this.providedStyle) {\n        this.providedStyle = this.providedStyleArray(this.props.column);\n      }\n\n      if (!_underscore2.default.isNull(this.providedStyle) && (!_underscore2.default.isArray(this.providedStyle) || this.providedStyle.length !== 3)) {\n        console.warn(\"Provided style to BoxChart should be an array of 3 objects\");\n        return defaultStyle;\n      }\n\n      var isHighlighted = this.props.highlighted && _pondjs.Event.is(this.props.highlighted, event);\n\n      var isSelected = this.props.selected && _pondjs.Event.is(this.props.selected, event);\n\n      if (this.props.selected) {\n        if (isSelected) {\n          if (!this.selectedStyle || !this.selectedStyle[level]) {\n            if (!this.selectedStyle) {\n              this.selectedStyle = [];\n            }\n\n            this.selectedStyle[level] = (0, _merge2.default)(true, defaultStyle[level].selected, this.providedStyle[level].selected ? this.providedStyle[level].selected : {});\n          }\n\n          style = this.selectedStyle[level];\n        } else if (isHighlighted) {\n          if (!this.highlightedStyle || !this.highlightedStyle[level]) {\n            if (!this.highlightedStyle) {\n              this.highlightedStyle = [];\n            }\n\n            this.highlightedStyle[level] = (0, _merge2.default)(true, defaultStyle[level].highlighted, this.providedStyle[level].highlighted ? this.providedStyle[level].highlighted : {});\n          }\n\n          style = this.highlightedStyle[level];\n        } else {\n          if (!this.mutedStyle) {\n            this.mutedStyle = [];\n          }\n\n          if (!this.mutedStyle[level]) {\n            this.mutedStyle[level] = (0, _merge2.default)(true, defaultStyle[level].muted, this.providedStyle[level].muted ? this.providedStyle[level].muted : {});\n          }\n\n          style = this.mutedStyle[level];\n        }\n      } else if (isHighlighted) {\n        style = (0, _merge2.default)(true, defaultStyle[level].highlighted, this.providedStyle[level].highlighted ? this.providedStyle[level].highlighted : {});\n      } else {\n        if (!this.normalStyle) {\n          this.normalStyle = [];\n        }\n\n        if (!this.normalStyle[level]) {\n          this.normalStyle[level] = (0, _merge2.default)(true, defaultStyle[level].normal, this.providedStyle[level].normal ? this.providedStyle[level].normal : {});\n        }\n\n        style = this.normalStyle[level];\n      }\n\n      return style;\n    }\n  }, {\n    key: \"renderBars\",\n    value: function renderBars() {\n      var _this2 = this;\n\n      var _props = this.props,\n          timeScale = _props.timeScale,\n          yScale = _props.yScale,\n          column = _props.column;\n      var innerSpacing = +this.props.innerSpacing;\n      var outerSpacing = +this.props.outerSpacing;\n      var innerSize = +this.props.innerSize;\n      var outerSize = +this.props.outerSize;\n      var bars = [];\n      var eventMarker = void 0;\n\n      var scaled = function scaled(d, field) {\n        return d.has(field) && !_underscore2.default.isUndefined(d.get(field)) && !_underscore2.default.isNaN(d.get(field)) ? yScale(d.get(field)) : null;\n      };\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var event = _step.value;\n          var index = event.index();\n          var begin = event.begin();\n          var end = event.end();\n          var d = event.data();\n          var beginPosInner = timeScale(begin) + innerSpacing;\n          var endPosInner = timeScale(end) - innerSpacing;\n          var beginPosOuter = timeScale(begin) + outerSpacing;\n          var endPosOuter = timeScale(end) - outerSpacing;\n          var innerWidth = innerSize || endPosInner - beginPosInner;\n\n          if (innerWidth < 1) {\n            innerWidth = 1;\n          }\n\n          var outerWidth = outerSize || endPosOuter - beginPosOuter;\n\n          if (outerWidth < 1) {\n            outerWidth = 1;\n          }\n\n          var c = timeScale(begin) + (timeScale(end) - timeScale(begin)) / 2;\n          var xInner = timeScale(begin) + innerSpacing;\n\n          if (innerSize) {\n            xInner = c - innerSize / 2;\n          }\n\n          var xOuter = timeScale(begin) + outerSpacing;\n\n          if (outerSize) {\n            xOuter = c - outerSize / 2;\n          }\n\n          var styles = [];\n          styles[0] = _this2.style(column, event, 0);\n          styles[1] = _this2.style(column, event, 1);\n          styles[2] = _this2.style(column, event, 2);\n          var innerMin = scaled(d, \"innerMin\");\n          var innerMax = scaled(d, \"innerMax\");\n          var outerMin = scaled(d, \"outerMin\");\n          var outerMax = scaled(d, \"outerMax\");\n          var center = scaled(d, \"center\");\n          var hasInner = true;\n          var hasOuter = true;\n          var hasCenter = true;\n\n          if (_underscore2.default.isNull(innerMin) || _underscore2.default.isNull(innerMax)) {\n            hasInner = false;\n          }\n\n          if (_underscore2.default.isNull(outerMin) || _underscore2.default.isNull(outerMax)) {\n            hasOuter = false;\n          }\n\n          if (_underscore2.default.isNull(center)) {\n            hasCenter = false;\n          }\n\n          var ymax = 0;\n\n          if (hasOuter) {\n            var level = 0;\n\n            if (!hasInner) {\n              level += 1;\n            }\n\n            if (!hasCenter) {\n              level += 1;\n            }\n\n            var keyOuter = (_this2.series.name() ? _this2.series.name() : \"series\") + \"-\" + index + \"-outer\";\n            var boxOuter = {\n              x: xOuter,\n              y: outerMax,\n              width: outerWidth,\n              height: outerMin - outerMax,\n              rx: 2,\n              ry: 2\n            };\n\n            var barOuterProps = _extends({\n              key: keyOuter\n            }, boxOuter, {\n              style: styles[level]\n            });\n\n            if (_this2.props.onSelectionChange) {\n              barOuterProps.onClick = function (e) {\n                return _this2.handleClick(e, event);\n              };\n            }\n\n            if (_this2.props.onHighlightChange) {\n              barOuterProps.onMouseMove = function (e) {\n                return _this2.handleHover(e, event);\n              };\n\n              barOuterProps.onMouseLeave = function () {\n                return _this2.handleHoverLeave();\n              };\n            }\n\n            bars.push(_react2.default.createElement(\"rect\", barOuterProps));\n            ymax = \"outerMax\";\n          }\n\n          if (hasInner) {\n            var _level = 1;\n\n            if (!hasCenter) {\n              _level += 1;\n            }\n\n            var keyInner = _this2.series.name() + \"-\" + index + \"-inner\";\n            var boxInner = {\n              x: xInner,\n              y: innerMax,\n              width: innerWidth,\n              height: innerMin - innerMax,\n              rx: 1,\n              ry: 1\n            };\n\n            var barInnerProps = _extends({\n              key: keyInner\n            }, boxInner, {\n              style: styles[_level]\n            });\n\n            if (_this2.props.onSelectionChange) {\n              barInnerProps.onClick = function (e) {\n                return _this2.handleClick(e, event);\n              };\n            }\n\n            if (_this2.props.onHighlightChange) {\n              barInnerProps.onMouseMove = function (e) {\n                return _this2.handleHover(e, event);\n              };\n\n              barInnerProps.onMouseLeave = function () {\n                return _this2.handleHoverLeave();\n              };\n            }\n\n            bars.push(_react2.default.createElement(\"rect\", barInnerProps));\n            ymax = ymax || \"innerMax\";\n          }\n\n          if (hasCenter) {\n            var _level2 = 2;\n            var keyCenter = _this2.series.name() + \"-\" + index + \"-center\";\n            var boxCenter = {\n              x: xInner,\n              y: center,\n              width: innerWidth,\n              height: 1\n            };\n\n            var barCenterProps = _extends({\n              key: keyCenter\n            }, boxCenter, {\n              style: styles[_level2]\n            });\n\n            if (_this2.props.onSelectionChange) {\n              barCenterProps.onClick = function (e) {\n                return _this2.handleClick(e, event);\n              };\n            }\n\n            if (_this2.props.onHighlightChange) {\n              barCenterProps.onMouseMove = function (e) {\n                return _this2.handleHover(e, event);\n              };\n\n              barCenterProps.onMouseLeave = function () {\n                return _this2.handleHoverLeave();\n              };\n            }\n\n            if (_underscore2.default.isNaN(barCenterProps.y)) {\n              console.log(d.toString());\n            }\n\n            bars.push(_react2.default.createElement(\"rect\", barCenterProps));\n            ymax = ymax || \"center\";\n          } // Event marker if info provided and hovering\n\n\n          var isHighlighted = _this2.props.highlighted && _pondjs.Event.is(_this2.props.highlighted, event);\n\n          if (isHighlighted && _this2.props.info) {\n            eventMarker = _react2.default.createElement(_EventMarker2.default, _extends({}, _this2.props, {\n              yValueFunc: function yValueFunc(e) {\n                return e.get(ymax);\n              },\n              event: event,\n              column: column,\n              marker: \"circle\",\n              markerRadius: 2\n            }));\n          }\n        };\n\n        for (var _iterator = this.series.events()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return _react2.default.createElement(\"g\", null, bars, eventMarker);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react2.default.createElement(\"g\", null, this.renderBars());\n    }\n  }]);\n\n  return BoxChart;\n}(_react2.default.Component);\n\nexports.default = BoxChart;\nBoxChart.propTypes = {\n  /**\n   * Show or hide this chart\n   */\n  visible: _propTypes2.default.bool,\n\n  /**\n   * What [Pond TimeSeries](https://esnet-pondjs.appspot.com/#/timeseries)\n   * data to visualize. See general notes on the BoxChart.\n   */\n  series: function series(props, propName, componentName) {\n    var value = props[propName];\n\n    if (!(value instanceof _pondjs.TimeSeries)) {\n      return new Error(\"A TimeSeries needs to be passed to \" + componentName + \" as the 'series' prop.\");\n    } // TODO: Better detection of errors\n    // everything ok\n\n\n    return null;\n  },\n\n  /**\n   * The column within the TimeSeries to plot. Unlike other charts, the BoxChart\n   * works on just a single column.\n   *\n   * NOTE : Columns can't have periods because periods\n   * represent a path to deep data in the underlying events\n   * (i.e. reference into nested data structures)\n   */\n  column: _propTypes2.default.string,\n\n  /**\n   * The aggregation specification. This object should contain:\n   *   - innerMax\n   *   - innerMin\n   *   - outerMax\n   *   - outerMin\n   *   - center\n   * Though each of the pairs, and center, is optional.\n   * For each of these keys you should supply the function you\n   * want to use to calculate these. You can import common functions\n   * from Pond, e.g. min(), avg(), percentile(95), etc.\n   *\n   * For example:\n   * ```\n   *     {\n   *       size: this.state.rollup,\n   *       reducers: {\n   *         outer: [min(), max()],\n   *         inner: [percentile(25), percentile(75)],\n   *         center: median(),\n   *       },\n   *     }\n   * ```\n   */\n  aggregation: _propTypes2.default.shape({\n    size: _propTypes2.default.string,\n    reducers: _propTypes2.default.shape({\n      inner: _propTypes2.default.arrayOf(_propTypes2.default.func),\n      // eslint-disable-line\n      outer: _propTypes2.default.arrayOf(_propTypes2.default.func),\n      // eslint-disable-line\n      center: _propTypes2.default.func // eslint-disable-line\n\n    })\n  }),\n  // eslint-disable-line\n\n  /**\n   * The style of the box chart drawing (using SVG CSS properties) or\n   * a styler object. It is recommended to user the styler unless you need\n   * detailed customization.\n   */\n  style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func, _propTypes2.default.instanceOf(_styler.Styler)]),\n\n  /**\n   * The style of the info box and connecting lines\n   */\n  infoStyle: _propTypes2.default.object,\n  //eslint-disable-line\n\n  /**\n   * The width of the hover info box\n   */\n  infoWidth: _propTypes2.default.number,\n  //eslint-disable-line\n\n  /**\n   * The height of the hover info box\n   */\n  infoHeight: _propTypes2.default.number,\n  //eslint-disable-line\n\n  /**\n   * The values to show in the info box. This is an array of\n   * objects, with each object specifying the label and value\n   * to be shown in the info box.\n   */\n  info: _propTypes2.default.arrayOf(_propTypes2.default.shape({\n    //eslint-disable-line\n    label: _propTypes2.default.string,\n    //eslint-disable-line\n    value: _propTypes2.default.string //eslint-disable-line\n\n  })),\n\n  /**\n   * If spacing is specified, then the boxes will be separated from the\n   * timerange boundary by this number of pixels. Use this to space out\n   * the boxes from each other. Inner and outer boxes are controlled\n   * separately.\n   */\n  innerSpacing: _propTypes2.default.number,\n\n  /**\n   * If spacing is specified, then the boxes will be separated from the\n   * timerange boundary by this number of pixels. Use this to space out\n   * the boxes from each other. Inner and outer boxes are controlled\n   * separately.\n   */\n  outerSpacing: _propTypes2.default.number,\n\n  /**\n   * If size is specified, then the innerBox will be this number of pixels wide. This\n   * prop takes priority over \"spacing\".\n   */\n  innerSize: _propTypes2.default.number,\n\n  /**\n   * If size is specified, then the outer box will be this number of pixels wide. This\n   * prop takes priority over \"spacing\".\n   */\n  outerSize: _propTypes2.default.number,\n\n  /**\n   * The selected item, which will be rendered in the \"selected\" style.\n   * If a bar is selected, all other bars will be rendered in the \"muted\" style.\n   *\n   * See also `onSelectionChange`\n   */\n  selected: _propTypes2.default.instanceOf(_pondjs.IndexedEvent),\n\n  /**\n   * The highlighted item, which will be rendered in the \"highlighted\" style.\n   *\n   * See also `onHighlightChange`\n   */\n  highlighted: _propTypes2.default.instanceOf(_pondjs.IndexedEvent),\n\n  /**\n   * A callback that will be called when the selection changes. It will be called\n   * with the event corresponding to the box clicked as its only arg.\n   */\n  onSelectionChange: _propTypes2.default.func,\n\n  /**\n   * A callback that will be called when the hovered over box changes.\n   * It will be called with the event corresponding to the box hovered over.\n   */\n  onHighlightChange: _propTypes2.default.func,\n\n  /**\n   * [Internal] The timeScale supplied by the surrounding ChartContainer\n   */\n  timeScale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The yScale supplied by the associated YAxis\n   */\n  yScale: _propTypes2.default.func,\n\n  /**\n   * [Internal] The width supplied by the surrounding ChartContainer\n   */\n  width: _propTypes2.default.number\n};\nBoxChart.defaultProps = {\n  visible: true,\n  column: \"value\",\n  innerSpacing: 1.0,\n  outerSpacing: 2.0,\n  infoStyle: {\n    stroke: \"#999\",\n    fill: \"white\",\n    opacity: 0.9,\n    pointerEvents: \"none\"\n  },\n  stemStyle: {\n    stroke: \"#999\",\n    cursor: \"crosshair\",\n    pointerEvents: \"none\"\n  },\n  markerStyle: {\n    fill: \"#999\"\n  },\n  markerRadius: 2,\n  infoWidth: 90,\n  infoHeight: 30\n};","map":null,"metadata":{},"sourceType":"script"}